{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de Desarrollo de Juegos Retro Con Mega Drive \u00b6 Este taller pretende ser una introducci\u00f3n al desarrollo de juegos retro, utilizando el sistema de entretenimiento desarrollado por Sega, Mega Drive (o Genesis en America). Durante este taller se aprender\u00e1 a instalar las liberias y herramientas necesarias para iniciarse en el desarrollo de juegos para la Sega Mega Drive. En este caso se utilizar\u00e1 el lenguaje C para poder desarrollar los juegos. Info Es necesario tener conocimientos de C y de programaci\u00f3n para iniciarse en este desarrollo. Tambi\u00e9n es conveniente tener algo de experiencia en el uso de consola o bash. Se comenzar\u00e1 mostrando que es una Sega Mega Drive y conociendo sus caracter\u00edsticas; adem\u00e1s de ver un poco la historia de esta videoconsola. Seguidamente, se hablara de las librerias y herramientas necesarias para trabajar; mostrando como instalar el software de desarrollo en distintos sistemas Operativos. Por \u00faltimo, se entrar\u00e1 en materia y se mostrara como funcionan las distintas caracteristicas necesarias para desarrollar juegos. Note Todo el contenido de esta p\u00e1gina esta licenciado bajo la licencia Creative Commons 4.0 By Sa , salvo que se indique lo contrario. El c\u00f3digo Fuente que se muestra esta licenciado bajo licencia MIT , mientras no se indique lo contrario. Sega y Mega Drive Son marcas registradas de Sega Sega Enterprises.","title":"Introducci\u00f3n"},{"location":"#taller-de-desarrollo-de-juegos-retro-con-mega-drive","text":"Este taller pretende ser una introducci\u00f3n al desarrollo de juegos retro, utilizando el sistema de entretenimiento desarrollado por Sega, Mega Drive (o Genesis en America). Durante este taller se aprender\u00e1 a instalar las liberias y herramientas necesarias para iniciarse en el desarrollo de juegos para la Sega Mega Drive. En este caso se utilizar\u00e1 el lenguaje C para poder desarrollar los juegos. Info Es necesario tener conocimientos de C y de programaci\u00f3n para iniciarse en este desarrollo. Tambi\u00e9n es conveniente tener algo de experiencia en el uso de consola o bash. Se comenzar\u00e1 mostrando que es una Sega Mega Drive y conociendo sus caracter\u00edsticas; adem\u00e1s de ver un poco la historia de esta videoconsola. Seguidamente, se hablara de las librerias y herramientas necesarias para trabajar; mostrando como instalar el software de desarrollo en distintos sistemas Operativos. Por \u00faltimo, se entrar\u00e1 en materia y se mostrara como funcionan las distintas caracteristicas necesarias para desarrollar juegos. Note Todo el contenido de esta p\u00e1gina esta licenciado bajo la licencia Creative Commons 4.0 By Sa , salvo que se indique lo contrario. El c\u00f3digo Fuente que se muestra esta licenciado bajo licencia MIT , mientras no se indique lo contrario. Sega y Mega Drive Son marcas registradas de Sega Sega Enterprises.","title":"Taller de Desarrollo de Juegos Retro Con Mega Drive"},{"location":"references/","text":"SGDK GENDEV Wikipedia: Sega mega Drive Wikipedia: Sega Mega CD Sega Retro: Documentaci\u00f3n Oficial mega Drive Motorola 68000 Charas-project RPG Maker 2003 Gens Pagina Oficial Gens KMod Visual Studio Code Genesis Code: pagina Descarga Repositorio Web y Ejemplos Foro de Desarrollo GenDev (SpritesMind)","title":"Referencias"},{"location":"devretro/controls/","text":"Controles en Mega Drive \u00b6 A la hora de trabajar con los controles de mega Drive, hay que tener en cuenta que hab\u00eda varios perifericos especiales para esta videoconsola. Como puede ser un segamouse ; o tener un adaptador para m\u00e1s de 2 controladores (como pod\u00eda ser los juegos con formato J-Cart). Es por ello que necesitamos conocer la manera de poder leer la entrada de los controles para poder hacer que el juego sea m\u00e1s interactivo; en el caso de usar SGDK, podemos hacerlo de forma s\u00edncrona o as\u00edncrona. Comenzaremos con la forma S\u00edncrona. Controles S\u00edncronos \u00b6 Como vimos en el apartado del hola mundo , vamos a crear una nueva carpeta que contenga otra carpeta llamda src y en este caso, otra llamada inc ; quedando el arbol de ficheros as\u00ed: miproyecto | ______src/ ______inc/ Una vez creadas las carpetas, crearemos un fichero llamado main.c que deber\u00e1 estar incluido dentro de la carpeta src. que tendr\u00e1 el siguiente contenido: /* Ejemplo 2: Controles. Este ejemplo permite ver como leer de forma sincrona los controles de la megaDrive */ #include <genesis.h> //Se inclue el fichero de constantes que hemos definido y debe ir en la carpeta inc #include \"constants.h\" //Definicion de la funcion ShowInputStatus; mostrara en pantalla cuando se pulse un boton void showInputStatus (); //Imprime un caracter en una posicion especifica void printChar ( char * , int , int ); int main () { //Se establece el ancho de pantalla a 320 VDP_setScreenWidth320 (); //Bucle infinito while ( 1 ) { //Se muestra el estado por pantalla showInputStatus (); //Se espera al refresco de pantalla VDP_waitVSync (); } return ( 0 ); } /** * Imprime por pantalla un texto en una posicion en Tiles * text-> Cadena de texto a imprimir * posx-> Posicion X en Tiles (1Tile = 8X8 pixels) * posy -> Posicion Y en Tiles (1 Tile = 8x8 Pixels) * */ void printChar ( char * text , int posx , int posy ) { VDP_drawText ( text , posx , posy ); } /** * Muestra por pantalla el estado de cada boton pulsado. * */ void showInputStatus () { //Se lee el estado del joistick en el puerto 1 int value = JOY_readJoypad ( JOY_1 ); if ( value & BUTTON_UP ) printChar ( UP_TEXT , POSX_UP , POSY_UP ); else printChar ( EMPTY_TEXT , POSX_UP , POSY_UP ); if ( value & BUTTON_LEFT ) printChar ( LEFT_TEXT , POSX_LEFT , POSY_LEFT ); else printChar ( EMPTY_TEXT , POSX_LEFT , POSY_LEFT ); if ( value & BUTTON_RIGHT ) printChar ( RIGTH_TEXT , POSX_RIGHT , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_RIGHT , POSY_RIGHT ); if ( value & BUTTON_DOWN ) printChar ( DOWN_TEXT , POSX_DOWN , POSY_DOWN ); else printChar ( EMPTY_TEXT , POSX_DOWN , POSY_DOWN ); if ( value & BUTTON_A ) printChar ( A_TEXT , POSX_A , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_A , POSY_RIGHT ); if ( value & BUTTON_B ) printChar ( B_TEXT , POSX_B , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_B , POSY_RIGHT ); if ( value & BUTTON_C ) printChar ( C_TEXT , POSX_C , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_C , POSY_RIGHT ); if ( value & BUTTON_START ) printChar ( START_TEXT , POSX_START , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_START , POSY_RIGHT ); } Como pod\u00e9is ver en el ejemplo, nos falta un fichero donde se encuentran todas las constantes que hemos definido; el cual pod\u00e9is descargar aqu\u00ed y ponerlo en la carpeta inc . Una vez los dos ficheros esten listos, podemos compilarlo y ejecutarlo en un emulador o consola. Note Recuerda : La rom compilada se encuentra en la carpeta out con el nombre rom.bin . Si ejecutamos usando un emulador la rom este ser\u00eda el aspecto: Controles Asincronos \u00b6 La forma anterior, es quizas menos eficiente ya que debemos esperar a que termine de dibujar toda la pantalla para poder leer de nuevo los controles. Es por ello que se requiere una forma as\u00edncrona que utilice la potencia de las interrupciones para poder ejecutar la lectura de los controles \"Cuando sea necesario\". Vamos a crear otro proyecto con la misma estructura anterior; (No olvides incluir el fichero .h). En este caso usaremos el siguiente c\u00f3digo fuente en el fichero main.c . Note Recuerda : Todos los ejemplos estaran disponible en el repositorio de este taller. Seguidamente mostramos el c\u00f3digo fuente: /* Ejemplo 4: Controles Asincronos. Uso de interrupciones para manejar controles. */ #include <genesis.h> //Libreria de constantes #include \"constants.h\" //Manejador de entrada void inputHandler ( u16 , u16 , u16 ); //Imprime un mensaje en pantalla void printChar ( char * , int , int ); //Funcion principal int main () { //inicializacion del sistema de controles JOY_init (); //Establecemos el manejador de entrada JOY_setEventHandler ( & inputHandler ); while ( 1 ) { VDP_waitVSync (); } return ( 0 ); } /** * Imprime por pantalla un texto en una posicion en Tiles * text-> Cadena de texto a imprimir * posx-> Posicion X en Tiles (1Tile = 8X8 pixels) * posy -> Posicion Y en Tiles (1 Tile = 8x8 Pixels) * */ void printChar ( char * text , int posx , int posy ) { VDP_drawText ( text , posx , posy ); } /** * Manejador de entrada * joy-> Indica el mando que ha activado la entrada * state -> Indica el estado del mando (boton activado) * changed -> indica si ha cambiado (pulsado o solatado) * */ void inputHandler ( u16 joy , u16 state , u16 changed ) { if ( changed & state & BUTTON_START ) { printChar ( START_TEXT , POSX_START , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_START , POSY_RIGHT ); } if ( changed & state & BUTTON_UP ) { printChar ( UP_TEXT , POSX_UP , POSY_UP ); } else { printChar ( EMPTY_TEXT , POSX_UP , POSY_UP ); } if ( changed & state & BUTTON_LEFT ) { printChar ( LEFT_TEXT , POSX_LEFT , POSY_LEFT ); } else { printChar ( EMPTY_TEXT , POSX_LEFT , POSY_LEFT ); } if ( changed & state & BUTTON_DOWN ) { printChar ( DOWN_TEXT , POSX_DOWN , POSY_DOWN ); } else { printChar ( EMPTY_TEXT , POSX_DOWN , POSY_DOWN ); } if ( changed & state & BUTTON_RIGHT ) { printChar ( RIGTH_TEXT , POSX_RIGHT , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_RIGHT , POSY_RIGHT ); } if ( changed & state & BUTTON_A ) { printChar ( A_TEXT , POSX_A , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_A , POSY_RIGHT ); } if ( changed & state & BUTTON_B ) { printChar ( B_TEXT , POSX_B , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_B , POSY_RIGHT ); } if ( changed & state & BUTTON_C ) { printChar ( C_TEXT , POSX_C , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_C , POSY_RIGHT ); } } Una vez que hemos visto como funcionan los controles, pasaremos a ver como funcionan los planos y como podemos a\u00f1adir recursos a nuestros proyectos.","title":"Controles"},{"location":"devretro/controls/#controles-en-mega-drive","text":"A la hora de trabajar con los controles de mega Drive, hay que tener en cuenta que hab\u00eda varios perifericos especiales para esta videoconsola. Como puede ser un segamouse ; o tener un adaptador para m\u00e1s de 2 controladores (como pod\u00eda ser los juegos con formato J-Cart). Es por ello que necesitamos conocer la manera de poder leer la entrada de los controles para poder hacer que el juego sea m\u00e1s interactivo; en el caso de usar SGDK, podemos hacerlo de forma s\u00edncrona o as\u00edncrona. Comenzaremos con la forma S\u00edncrona.","title":"Controles en Mega Drive"},{"location":"devretro/controls/#controles-sincronos","text":"Como vimos en el apartado del hola mundo , vamos a crear una nueva carpeta que contenga otra carpeta llamda src y en este caso, otra llamada inc ; quedando el arbol de ficheros as\u00ed: miproyecto | ______src/ ______inc/ Una vez creadas las carpetas, crearemos un fichero llamado main.c que deber\u00e1 estar incluido dentro de la carpeta src. que tendr\u00e1 el siguiente contenido: /* Ejemplo 2: Controles. Este ejemplo permite ver como leer de forma sincrona los controles de la megaDrive */ #include <genesis.h> //Se inclue el fichero de constantes que hemos definido y debe ir en la carpeta inc #include \"constants.h\" //Definicion de la funcion ShowInputStatus; mostrara en pantalla cuando se pulse un boton void showInputStatus (); //Imprime un caracter en una posicion especifica void printChar ( char * , int , int ); int main () { //Se establece el ancho de pantalla a 320 VDP_setScreenWidth320 (); //Bucle infinito while ( 1 ) { //Se muestra el estado por pantalla showInputStatus (); //Se espera al refresco de pantalla VDP_waitVSync (); } return ( 0 ); } /** * Imprime por pantalla un texto en una posicion en Tiles * text-> Cadena de texto a imprimir * posx-> Posicion X en Tiles (1Tile = 8X8 pixels) * posy -> Posicion Y en Tiles (1 Tile = 8x8 Pixels) * */ void printChar ( char * text , int posx , int posy ) { VDP_drawText ( text , posx , posy ); } /** * Muestra por pantalla el estado de cada boton pulsado. * */ void showInputStatus () { //Se lee el estado del joistick en el puerto 1 int value = JOY_readJoypad ( JOY_1 ); if ( value & BUTTON_UP ) printChar ( UP_TEXT , POSX_UP , POSY_UP ); else printChar ( EMPTY_TEXT , POSX_UP , POSY_UP ); if ( value & BUTTON_LEFT ) printChar ( LEFT_TEXT , POSX_LEFT , POSY_LEFT ); else printChar ( EMPTY_TEXT , POSX_LEFT , POSY_LEFT ); if ( value & BUTTON_RIGHT ) printChar ( RIGTH_TEXT , POSX_RIGHT , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_RIGHT , POSY_RIGHT ); if ( value & BUTTON_DOWN ) printChar ( DOWN_TEXT , POSX_DOWN , POSY_DOWN ); else printChar ( EMPTY_TEXT , POSX_DOWN , POSY_DOWN ); if ( value & BUTTON_A ) printChar ( A_TEXT , POSX_A , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_A , POSY_RIGHT ); if ( value & BUTTON_B ) printChar ( B_TEXT , POSX_B , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_B , POSY_RIGHT ); if ( value & BUTTON_C ) printChar ( C_TEXT , POSX_C , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_C , POSY_RIGHT ); if ( value & BUTTON_START ) printChar ( START_TEXT , POSX_START , POSY_RIGHT ); else printChar ( EMPTY_TEXT , POSX_START , POSY_RIGHT ); } Como pod\u00e9is ver en el ejemplo, nos falta un fichero donde se encuentran todas las constantes que hemos definido; el cual pod\u00e9is descargar aqu\u00ed y ponerlo en la carpeta inc . Una vez los dos ficheros esten listos, podemos compilarlo y ejecutarlo en un emulador o consola. Note Recuerda : La rom compilada se encuentra en la carpeta out con el nombre rom.bin . Si ejecutamos usando un emulador la rom este ser\u00eda el aspecto:","title":"Controles S\u00edncronos"},{"location":"devretro/controls/#controles-asincronos","text":"La forma anterior, es quizas menos eficiente ya que debemos esperar a que termine de dibujar toda la pantalla para poder leer de nuevo los controles. Es por ello que se requiere una forma as\u00edncrona que utilice la potencia de las interrupciones para poder ejecutar la lectura de los controles \"Cuando sea necesario\". Vamos a crear otro proyecto con la misma estructura anterior; (No olvides incluir el fichero .h). En este caso usaremos el siguiente c\u00f3digo fuente en el fichero main.c . Note Recuerda : Todos los ejemplos estaran disponible en el repositorio de este taller. Seguidamente mostramos el c\u00f3digo fuente: /* Ejemplo 4: Controles Asincronos. Uso de interrupciones para manejar controles. */ #include <genesis.h> //Libreria de constantes #include \"constants.h\" //Manejador de entrada void inputHandler ( u16 , u16 , u16 ); //Imprime un mensaje en pantalla void printChar ( char * , int , int ); //Funcion principal int main () { //inicializacion del sistema de controles JOY_init (); //Establecemos el manejador de entrada JOY_setEventHandler ( & inputHandler ); while ( 1 ) { VDP_waitVSync (); } return ( 0 ); } /** * Imprime por pantalla un texto en una posicion en Tiles * text-> Cadena de texto a imprimir * posx-> Posicion X en Tiles (1Tile = 8X8 pixels) * posy -> Posicion Y en Tiles (1 Tile = 8x8 Pixels) * */ void printChar ( char * text , int posx , int posy ) { VDP_drawText ( text , posx , posy ); } /** * Manejador de entrada * joy-> Indica el mando que ha activado la entrada * state -> Indica el estado del mando (boton activado) * changed -> indica si ha cambiado (pulsado o solatado) * */ void inputHandler ( u16 joy , u16 state , u16 changed ) { if ( changed & state & BUTTON_START ) { printChar ( START_TEXT , POSX_START , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_START , POSY_RIGHT ); } if ( changed & state & BUTTON_UP ) { printChar ( UP_TEXT , POSX_UP , POSY_UP ); } else { printChar ( EMPTY_TEXT , POSX_UP , POSY_UP ); } if ( changed & state & BUTTON_LEFT ) { printChar ( LEFT_TEXT , POSX_LEFT , POSY_LEFT ); } else { printChar ( EMPTY_TEXT , POSX_LEFT , POSY_LEFT ); } if ( changed & state & BUTTON_DOWN ) { printChar ( DOWN_TEXT , POSX_DOWN , POSY_DOWN ); } else { printChar ( EMPTY_TEXT , POSX_DOWN , POSY_DOWN ); } if ( changed & state & BUTTON_RIGHT ) { printChar ( RIGTH_TEXT , POSX_RIGHT , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_RIGHT , POSY_RIGHT ); } if ( changed & state & BUTTON_A ) { printChar ( A_TEXT , POSX_A , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_A , POSY_RIGHT ); } if ( changed & state & BUTTON_B ) { printChar ( B_TEXT , POSX_B , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_B , POSY_RIGHT ); } if ( changed & state & BUTTON_C ) { printChar ( C_TEXT , POSX_C , POSY_RIGHT ); } else { printChar ( EMPTY_TEXT , POSX_C , POSY_RIGHT ); } } Una vez que hemos visto como funcionan los controles, pasaremos a ver como funcionan los planos y como podemos a\u00f1adir recursos a nuestros proyectos.","title":"Controles Asincronos"},{"location":"devretro/planes/","text":"Planos (Layers) \u00b6 Uno de los recursos con los que se suele trabajar a la hora de crear videojuegos, son las capas o planos. Con ellos podemos a\u00f1adir contenido a nuestro juego y dar sensaci\u00f3n de profundidad o poder mostrar alguna animaci\u00f3n que este ocurriendo en ese momento. En este apartado, como introducci\u00f3n al manejo de recursos con MegaDrive aprenderemos a usar las capas o planos para dar sensaci\u00f3n de profundidad a nuestros juegos. Imagenes en Mega Drive \u00b6 En primer lugar, vamos a ver como se manejan imagenes o recursos dentro de la propia Mega Drive. Es impotante tener en cuenta los siguientes conceptos ya que de otra forma no se nos motrar\u00e1n bien las imagenes o incluso nuestro juego no funcionar\u00eda: En cada refresco, se pintan 2 planos a la vez ( adem\u00e1s de la capa de los sprites) Cada plano esta compuesto por Tiles que pueden estar compuestos por distintos tama\u00f1os (Por defecto 8x8 pixels). Solo se pueden tener 4096 Tiles en memoria. cada plano es dibujado de izquierda a derecha y de arriba a abajo. Cada plano puede ser dibujado por una de las 4 paletas disponibles. El primer Tile es usado para dibujar el fondo. Note Recuerda : Todos los recursos del juego deben ir en la carpeta res . Para a\u00f1adir una imagen para cargarla como plano, debemos a\u00f1adirla a la carpeta de recursos. Seguidamente crear un fichero con extension .res ; y a continuaci\u00f3n a\u00f1adir el siguiente contenido. IMAGE bga_image \"gfx/bgc.bmp\" BEST IMAGE bgb_image \"gfx/bgb.bmp\" BEST Como podemos ver se trata de un fichero que define cada recurso de la siguiente manera: Tipo de recurso : En este caso de tipo IMAGE. Nombre del recurso : Nombre que daremos al recurso Ruta relativa al fichero : Ruta donde se encuentra el fichero de imagen. Tipo de compresion : Tipo de compresion que se le puede a\u00f1adir a la imagen para ser almacenada; en este caso se busca la mejor (BEST). Una vez a\u00f1adido el fichero de recursos y si compilamos el proyecto, veremos que se a\u00f1ade en la carpeta res un fichero .h; este fichero .h contiene la referencia a nuestros recursos que podremos a\u00f1adir a nuestro proyecto. Si por ejemplo hemos creado el fichero gfx.res , al compilar obtendremos el fichero gfx.h . Despu\u00e9s para referenciarlo en nuestro proyecto, lo \u00fanico que debemos hacer es: #include \"gfx.h\" Paleta de colores \u00b6 Hemos de tener en cuenta tambi\u00e9n que las imagenes en Mega Drive no son RGB ya que utilizan una paleta para poder referenciar los colores; en este caso ser\u00edan imagenes indexadas. Cada paleta solo tiene hasta 16 colores. Esto es importante a la hora de exportar imagenes. Note Al tener una paleta de 16 colores, es necesario que el fichero (bmp o png) que contiene la imagen debe tener una profundida de bits de 4 u 8 bpp. Planos o capas \u00b6 Una vez sabemos como a\u00f1adir recursos de imagen a nuestro poyecto, vamos a mostrar como a\u00f1adir planos y cargarlos en nuestros juegos para que se muestren. En primer lugar, hay que saber que con SGDK, podemos trabajar con 2 planos a la vez (aunque podemos utilizar un tercer plano usando Sprites). En primer lugar, hay que saber que al trabajar con paletas es importante saber que se esta cargando correctamente con la paleta que corresponde. SGDK permite trabajar con 4 paletas de 16 colores a la vez. Por lo que es importante saber con que colores estamos trabajando. Para poder dibujar un plano, se utiliza la siguiente funci\u00f3n: VDP_drawImageEx(BG_B, &bga_image, TILE_ATTR_FULL(PAL1, FALSE, FALSE, FALSE, ind), 0, 0, FALSE, TRUE); Esta funci\u00f3n, tiene los siguientes parametros: plano: Indica el plano que dibujara BG_A o BG_B. nombre del recurso: Es el nombre que hemos puesto en el fichero res . Tile Base: Indica en el Tile donde se dibujara; es por ello que usamos la macro TILE_ATTR_FULL . Posicion X: Posicion Inicial X donde se dibujara. Posicion Y: Posicion Inicial Y donde se dibujara. Cargar Paleta: Indica si se debe cargar la paleta de la imagen o no si ya se habia cargado previamente. Modo Carga: Indica como se debe cargar, puede ser CPU, DMA o DMA_QUEUE; por defecto es CPU. Si se deja como FALSE se usara la CPU. Note La macro TILE_ATTR_FULL permite definir el Tile base desde el que se dibujara la imagen o plano. En este caso tiene los siguientes par\u00e1metros: Paleta a utilizar: puede ser PAL_0 , PAL_1 , PAL_2 o PAL_3 . Prioridad: indica si el plano tiene prioridad. VFlip: indica si se volteara verticalmente. HFlip: Indica si se volteara horizontalmente. indice: Indica el indice en memoria desde el que se cargara. Como hemos podido ver a la hora de trabajar con planos, Se pueden trabajar con 2 a la vez; sin embargo, si utilizamos las prioridades y la capa de sprites, esto se puede ampliar. Vamos a mostrar un esquema para ver la prioridad y como se dibujan los planos; pudiendo jugar con la transparencia y por ello hacer la sensaci\u00f3n de profundidad. Ejemplo con Planos \u00b6 Una vez que hemos visto como manejar los planos y como se dibujan en la Mega Drive, pasaremos a ver un ejemplo usando dos imagenes para dar una sensaci\u00f3n de profundidad. Una aparecer\u00e1 un terreno por donde se puede avanzar y otro ser\u00e1 el cielo que se mostrar\u00e1 de fondo. Dejamos aqu\u00ed las dos imagenes y la correspondiente descarga de la misma con 4bpp de profundidad. Enlace de descarga de las imagenes Una vez descargadas las imagenes y creado un nuevo proyecto, podemos pasar a a\u00f1adir estas a la carpeta res ; para una mejor organizaci\u00f3n a\u00f1adiremos dentro de esta una carpeta llamda gfx . En la cual a\u00f1adiremos las 2 imagenes. Una vez a\u00f1adidas las imagenes, crearemos el fichero gfx.res dentro de la carpeta res; con el siguiente contenido: IMAGE bga_image \"gfx/bgc.bmp\" BEST IMAGE bgb_image \"gfx/bgb.bmp\" BEST Tras terminar esto, compilaremos el proyecto y veremos como se genera un fichero llamado gfx.h dentro de la carpeta res. Una vez hecho esto, crearemos el fichero main.c en la carpeta src, con el siguiente contenido: /** Ejemplo5: Ejemplo de planos con Mega Drive **/ //Incluir libreria #include <genesis.h> // Incluir los recursos #include \"gfx.h\" //Funcion Principal int main () { //array donde se almacenara las paletas u16 palette [ 32 ]; //Para evitar problemas, se deshabilitan las interrupciones durante la carga SYS_disableInts (); // initializacion a 320 de ancho VDP_setScreenWidth320 (); // se establecen los colores de la paleta a negro VDP_setPaletteColors ( 0 , ( u16 * ) palette_black , 32 ); //Indice para pdoer saber la carga u16 ind = TILE_USERINDEX ; //dibuja un plano a partir de un recurso VDP_drawImageEx ( BG_B , & bga_image , TILE_ATTR_FULL ( PAL1 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bga_image . tileset -> numTile ; VDP_drawImageEx ( BG_A , & bgb_image , TILE_ATTR_FULL ( PAL0 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bgb_image . tileset -> numTile ; //Se vuelven a activar las interrupciones SYS_enableInts (); // prepare palettes memcpy ( & palette [ 0 ], bgb_image . palette -> data , 16 * 2 ); memcpy ( & palette [ 16 ], bga_image . palette -> data , 16 * 2 ); // fade in VDP_fadeIn ( 0 , ( 2 * 16 ) - 1 , palette , 20 , FALSE ); // bucle infinito while ( 1 ) { //Esperar refresco VDP_waitVSync (); } } Note Es posible que los usuarios con GENDEV falle la compilacion; esto es debido la la actualizacion de SGDK a la version 1.50. Cambiad en el ejemplo BG_A por PLAN_A y BG_B por PLAN_B . Una vez compilado el proyecto, si lo ejecutamos en un emulador saldr\u00e1 m\u00e1s o menos as\u00ed:","title":"Planos"},{"location":"devretro/planes/#planos-layers","text":"Uno de los recursos con los que se suele trabajar a la hora de crear videojuegos, son las capas o planos. Con ellos podemos a\u00f1adir contenido a nuestro juego y dar sensaci\u00f3n de profundidad o poder mostrar alguna animaci\u00f3n que este ocurriendo en ese momento. En este apartado, como introducci\u00f3n al manejo de recursos con MegaDrive aprenderemos a usar las capas o planos para dar sensaci\u00f3n de profundidad a nuestros juegos.","title":"Planos (Layers)"},{"location":"devretro/planes/#imagenes-en-mega-drive","text":"En primer lugar, vamos a ver como se manejan imagenes o recursos dentro de la propia Mega Drive. Es impotante tener en cuenta los siguientes conceptos ya que de otra forma no se nos motrar\u00e1n bien las imagenes o incluso nuestro juego no funcionar\u00eda: En cada refresco, se pintan 2 planos a la vez ( adem\u00e1s de la capa de los sprites) Cada plano esta compuesto por Tiles que pueden estar compuestos por distintos tama\u00f1os (Por defecto 8x8 pixels). Solo se pueden tener 4096 Tiles en memoria. cada plano es dibujado de izquierda a derecha y de arriba a abajo. Cada plano puede ser dibujado por una de las 4 paletas disponibles. El primer Tile es usado para dibujar el fondo. Note Recuerda : Todos los recursos del juego deben ir en la carpeta res . Para a\u00f1adir una imagen para cargarla como plano, debemos a\u00f1adirla a la carpeta de recursos. Seguidamente crear un fichero con extension .res ; y a continuaci\u00f3n a\u00f1adir el siguiente contenido. IMAGE bga_image \"gfx/bgc.bmp\" BEST IMAGE bgb_image \"gfx/bgb.bmp\" BEST Como podemos ver se trata de un fichero que define cada recurso de la siguiente manera: Tipo de recurso : En este caso de tipo IMAGE. Nombre del recurso : Nombre que daremos al recurso Ruta relativa al fichero : Ruta donde se encuentra el fichero de imagen. Tipo de compresion : Tipo de compresion que se le puede a\u00f1adir a la imagen para ser almacenada; en este caso se busca la mejor (BEST). Una vez a\u00f1adido el fichero de recursos y si compilamos el proyecto, veremos que se a\u00f1ade en la carpeta res un fichero .h; este fichero .h contiene la referencia a nuestros recursos que podremos a\u00f1adir a nuestro proyecto. Si por ejemplo hemos creado el fichero gfx.res , al compilar obtendremos el fichero gfx.h . Despu\u00e9s para referenciarlo en nuestro proyecto, lo \u00fanico que debemos hacer es: #include \"gfx.h\"","title":"Imagenes en Mega Drive"},{"location":"devretro/planes/#paleta-de-colores","text":"Hemos de tener en cuenta tambi\u00e9n que las imagenes en Mega Drive no son RGB ya que utilizan una paleta para poder referenciar los colores; en este caso ser\u00edan imagenes indexadas. Cada paleta solo tiene hasta 16 colores. Esto es importante a la hora de exportar imagenes. Note Al tener una paleta de 16 colores, es necesario que el fichero (bmp o png) que contiene la imagen debe tener una profundida de bits de 4 u 8 bpp.","title":"Paleta de colores"},{"location":"devretro/planes/#planos-o-capas","text":"Una vez sabemos como a\u00f1adir recursos de imagen a nuestro poyecto, vamos a mostrar como a\u00f1adir planos y cargarlos en nuestros juegos para que se muestren. En primer lugar, hay que saber que con SGDK, podemos trabajar con 2 planos a la vez (aunque podemos utilizar un tercer plano usando Sprites). En primer lugar, hay que saber que al trabajar con paletas es importante saber que se esta cargando correctamente con la paleta que corresponde. SGDK permite trabajar con 4 paletas de 16 colores a la vez. Por lo que es importante saber con que colores estamos trabajando. Para poder dibujar un plano, se utiliza la siguiente funci\u00f3n: VDP_drawImageEx(BG_B, &bga_image, TILE_ATTR_FULL(PAL1, FALSE, FALSE, FALSE, ind), 0, 0, FALSE, TRUE); Esta funci\u00f3n, tiene los siguientes parametros: plano: Indica el plano que dibujara BG_A o BG_B. nombre del recurso: Es el nombre que hemos puesto en el fichero res . Tile Base: Indica en el Tile donde se dibujara; es por ello que usamos la macro TILE_ATTR_FULL . Posicion X: Posicion Inicial X donde se dibujara. Posicion Y: Posicion Inicial Y donde se dibujara. Cargar Paleta: Indica si se debe cargar la paleta de la imagen o no si ya se habia cargado previamente. Modo Carga: Indica como se debe cargar, puede ser CPU, DMA o DMA_QUEUE; por defecto es CPU. Si se deja como FALSE se usara la CPU. Note La macro TILE_ATTR_FULL permite definir el Tile base desde el que se dibujara la imagen o plano. En este caso tiene los siguientes par\u00e1metros: Paleta a utilizar: puede ser PAL_0 , PAL_1 , PAL_2 o PAL_3 . Prioridad: indica si el plano tiene prioridad. VFlip: indica si se volteara verticalmente. HFlip: Indica si se volteara horizontalmente. indice: Indica el indice en memoria desde el que se cargara. Como hemos podido ver a la hora de trabajar con planos, Se pueden trabajar con 2 a la vez; sin embargo, si utilizamos las prioridades y la capa de sprites, esto se puede ampliar. Vamos a mostrar un esquema para ver la prioridad y como se dibujan los planos; pudiendo jugar con la transparencia y por ello hacer la sensaci\u00f3n de profundidad.","title":"Planos o capas"},{"location":"devretro/planes/#ejemplo-con-planos","text":"Una vez que hemos visto como manejar los planos y como se dibujan en la Mega Drive, pasaremos a ver un ejemplo usando dos imagenes para dar una sensaci\u00f3n de profundidad. Una aparecer\u00e1 un terreno por donde se puede avanzar y otro ser\u00e1 el cielo que se mostrar\u00e1 de fondo. Dejamos aqu\u00ed las dos imagenes y la correspondiente descarga de la misma con 4bpp de profundidad. Enlace de descarga de las imagenes Una vez descargadas las imagenes y creado un nuevo proyecto, podemos pasar a a\u00f1adir estas a la carpeta res ; para una mejor organizaci\u00f3n a\u00f1adiremos dentro de esta una carpeta llamda gfx . En la cual a\u00f1adiremos las 2 imagenes. Una vez a\u00f1adidas las imagenes, crearemos el fichero gfx.res dentro de la carpeta res; con el siguiente contenido: IMAGE bga_image \"gfx/bgc.bmp\" BEST IMAGE bgb_image \"gfx/bgb.bmp\" BEST Tras terminar esto, compilaremos el proyecto y veremos como se genera un fichero llamado gfx.h dentro de la carpeta res. Una vez hecho esto, crearemos el fichero main.c en la carpeta src, con el siguiente contenido: /** Ejemplo5: Ejemplo de planos con Mega Drive **/ //Incluir libreria #include <genesis.h> // Incluir los recursos #include \"gfx.h\" //Funcion Principal int main () { //array donde se almacenara las paletas u16 palette [ 32 ]; //Para evitar problemas, se deshabilitan las interrupciones durante la carga SYS_disableInts (); // initializacion a 320 de ancho VDP_setScreenWidth320 (); // se establecen los colores de la paleta a negro VDP_setPaletteColors ( 0 , ( u16 * ) palette_black , 32 ); //Indice para pdoer saber la carga u16 ind = TILE_USERINDEX ; //dibuja un plano a partir de un recurso VDP_drawImageEx ( BG_B , & bga_image , TILE_ATTR_FULL ( PAL1 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bga_image . tileset -> numTile ; VDP_drawImageEx ( BG_A , & bgb_image , TILE_ATTR_FULL ( PAL0 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bgb_image . tileset -> numTile ; //Se vuelven a activar las interrupciones SYS_enableInts (); // prepare palettes memcpy ( & palette [ 0 ], bgb_image . palette -> data , 16 * 2 ); memcpy ( & palette [ 16 ], bga_image . palette -> data , 16 * 2 ); // fade in VDP_fadeIn ( 0 , ( 2 * 16 ) - 1 , palette , 20 , FALSE ); // bucle infinito while ( 1 ) { //Esperar refresco VDP_waitVSync (); } } Note Es posible que los usuarios con GENDEV falle la compilacion; esto es debido la la actualizacion de SGDK a la version 1.50. Cambiad en el ejemplo BG_A por PLAN_A y BG_B por PLAN_B . Una vez compilado el proyecto, si lo ejecutamos en un emulador saldr\u00e1 m\u00e1s o menos as\u00ed:","title":"Ejemplo con Planos"},{"location":"devretro/sound-music/","text":"Musica y Sonido en SGDK \u00b6 A la hora de crear juegos interactivos, siempre es importante el apartado sonoro. En este apartado, vamos a mostrar como a\u00f1adir m\u00fasica y sonido a nuestros juegos. En este apartado se mostrar\u00e1 como crear y a\u00f1adir musica a nuestra mega drive. Sonido en Mega Drive \u00b6 En primer lugar, tenemos que ver como funciona el sistema de sonido que trae la sega Mega Drive; Mega Drive dispone de los siguientes chips de sonido: Chip Yamaha YM2612 FM Chip. Texas Instruments PSG TI6489. Procesador Z80 para orquestar el sonido. Como podemos ver, hay 2 chips de sonido uno FM y otro para sonidos (8bit), estos dos chips son controlados por el controlador Z80 que es el encargado de funcionar. Note El procesador Z80 es el encargado de dar retrocompatibilidad con Master System por lo que en dicho modo no se tendr\u00e1 acceso al chip FM y solo estar\u00e1 disponible el PSG. El chip Yamaha YM2612, permite hasta 6 canales de audio en estereo teniendo una gran calidad de sonido; adem\u00e1s gracias al chip PSG se pueden combinar para poder ejecutar sonido y musica a la vez. Formato M\u00fasica XGM(vgm) \u00b6 A la hora de trabajar con la musica de Mega Drive /Genesis, vamos a ver un programa llamado VGM Music Maker; el cual nos permitir\u00e1 poder crear m\u00fasica para el chip Yamaha YM2612 y el PSG a la vez y poder crear nuestra musica a partir de instrumentos sintetizados. Una vez creada la m\u00fasica se debe exportar en formago XGM (extensi\u00f3n vgm). Adicionalmente, se pueden a\u00f1adir ficheros wav para los efectos de sonido. A\u00f1adir sonido a nuestros juegos \u00b6 Una vez ya hemos creado la musica y sonidos preparados, vamos a\u00f1adirlos a nuestro proyecto. En este caso, usaremos de forma analoga a como lo hicimos con los sprites y los fondos. Por lo que crearemos un fichero .res con la siguiente informaci\u00f3n: XGM sonic1 \"sonic1.vgm\" AUTO Donde: name: nombre del recurso. \"ruta\": ruta del fichero relativa a la carpeta res. AUTO: indica el TIMING; puede ser AUTO, PAL o NTSC. A la hora de a\u00f1adir ficheros de sonido, tendremos que utilizar la siguiente sintaxis. WAV name \"jump.wav\" PCM name: nombre del recurso. \"ruta\". Ruta del fichero relativa a la carpeta res. driver: indica el driver a utilizar (PCM, A2ADPCM, 4PCM, XGM). outrate: (solo si se usa el driver PCM). Una vez a\u00f1adidos los ficheros .res , compilaremos el proyecto y ya tendremos el fichero .h generado con todos los recursos. Tras haber a\u00f1adido los ficheros, vamos a ver las funciones que podemos utilizar para reproducir musica y sonido con SGDK. SND_startPlay_XGM(sonic_music); Esta funci\u00f3n reproduce la musica usando el fichero en formato XGM. En este caso, se reproducir\u00e1 por defecto en bucle. Note Es recomendable ejecutar esta funci\u00f3n deshabilitando las interrupciones; es decir, entre las funciones SYS_disableInts() y SYS_enableInts(); . SND_setPCM_XGM(SFX_JUMP, sonic_jump_sfx, sizeof(sonic_jump_sfx)) Esta funci\u00f3n inicializa el recurso de sonido, utilizando el driver correspondiente; en este caso el driver XGM. Estos son los par\u00e1metros de esta funci\u00f3n: ID: Identificador que le daremos al recurso (suele ser un n\u00famero). nombre_recurso: Nombre del recurso definido en el .res. tama\u00f1o: Tama\u00f1o del so0nido. SND_startPlayPCM_XGM(SFX_STOP, 1, SOUND_PCM_CH2); Esta funci\u00f3n reproduce el sonido inicializado con la anterior funci\u00f3n seleccionando el canal por que se reproducir\u00e1. Estos son los par\u00e1metros de la funci\u00f3n: ID: Identificador que se ha dado al inicializar el sonido. N_veces: N\u00ba de veces a reproducir. CANAL: Canal en el que reproducir este sonido. por ejemplo SOUND_PCM_CH2. Ejemplo con musica. \u00b6 Para terminar, vamos a finalizar el ejemplo que hemos realizado en este taller, a\u00f1adiendo m\u00fasica a nuestro juego; para ello, necesitaremos un fichero en formago vgm que puede descargar desde aqu\u00ed . Una vez se ha a\u00f1adido el fichero, pondremos el siguiente c\u00f3digo. /** Ejemplo5: Ejemplo de planos con Mega Drive **/ //Incluir libreria #include <genesis.h> // Incluir los recursos #include \"gfx.h\" #include \"sprt.h\" #include \"music.h\" //animaciones #define ANIM_RIGTH 1 #define ANIM_LEFT 3 #define ANIM_DOWN 2 #define ANIM_UP 0 #define ANIM_STAY 4 //Esta funcion nos ayudara a leer los controles void readcontrollers (); //Sprite Principal Sprite * mainsprt ; //Sprite Secundario Sprite * secondsprt ; u32 posx = 45 ; u32 posy = 155 ; //Funcion Principal int main () { //array donde se almacenara las paletas u16 palette [ 32 ]; //Para evitar problemas, se deshabilitan las interrupciones durante la carga SYS_disableInts (); // initializacion a 320 de ancho VDP_setScreenWidth320 (); // se establecen los colores de la paleta a negro VDP_setPaletteColors ( 0 , ( u16 * ) palette_black , 32 ); //Indice para pdoer saber la carga u16 ind = TILE_USERINDEX ; //dibuja un plano a partir de un recurso VDP_drawImageEx ( BG_B , & bga_image , TILE_ATTR_FULL ( PAL1 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bga_image . tileset -> numTile ; VDP_drawImageEx ( BG_A , & bgb_image , TILE_ATTR_FULL ( PAL0 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bgb_image . tileset -> numTile ; SND_startPlay_XGM ( theme ); //Se vuelven a activar las interrupciones SYS_enableInts (); //Inicializa motor de sprites con los par\u00e1metros por defecto SPR_init ( 0 , 0 , 0 ); mainsprt = SPR_addSprite ( & main_sprt , 15 , 125 , TILE_ATTR_FULL ( PAL2 , TRUE , FALSE , FALSE , ind )); secondsprt = SPR_addSprite ( & elli_sprt , 45 , 155 , TILE_ATTR ( PAL3 , TRUE , FALSE , FALSE )); // prepare palettes memcpy ( & palette [ 0 ], bgb_image . palette -> data , 16 * 2 ); memcpy ( & palette [ 16 ], bga_image . palette -> data , 16 * 2 ); VDP_setPalette ( PAL2 , main_sprt . palette -> data ); VDP_setPalette ( PAL3 , elli_sprt . palette -> data ); SPR_setAnim ( mainsprt , ANIM_STAY ); SPR_setAnim ( secondsprt , ANIM_STAY ); // fade in VDP_fadeIn ( 0 , ( 2 * 16 ) - 1 , palette , 20 , FALSE ); // bucle infinito while ( 1 ) { readcontrollers (); //actualiza el VDP SPR_update (); //Esperar refresco VDP_waitVSync (); } } void readcontrollers () { //Se lee el estado del joistick en el puerto 1 int value = JOY_readJoypad ( JOY_1 ); if ( value & BUTTON_RIGHT ){ SPR_setPosition ( secondsprt , posx ++ , posy ); SPR_setAnim ( secondsprt , ANIM_RIGTH ); } if ( value & BUTTON_LEFT ){ SPR_setPosition ( secondsprt , posx -- , posy ); SPR_setAnim ( secondsprt , ANIM_LEFT ); } if ( value & BUTTON_DOWN ) { SPR_setPosition ( secondsprt , posx , posy ++ ); SPR_setAnim ( secondsprt , ANIM_DOWN ); } if ( value & BUTTON_UP ) { SPR_setPosition ( secondsprt , posx , posy -- ); SPR_setAnim ( secondsprt , ANIM_UP ); } if ((( ! ( value & BUTTON_RIGHT )) && ( ! ( value & BUTTON_LEFT ))) && (( ! ( value & BUTTON_DOWN )) && ( ! ( value & BUTTON_UP )))) { SPR_setAnim ( secondsprt , ANIM_STAY ); } }","title":"Musica y sonido"},{"location":"devretro/sound-music/#musica-y-sonido-en-sgdk","text":"A la hora de crear juegos interactivos, siempre es importante el apartado sonoro. En este apartado, vamos a mostrar como a\u00f1adir m\u00fasica y sonido a nuestros juegos. En este apartado se mostrar\u00e1 como crear y a\u00f1adir musica a nuestra mega drive.","title":"Musica y Sonido en SGDK"},{"location":"devretro/sound-music/#sonido-en-mega-drive","text":"En primer lugar, tenemos que ver como funciona el sistema de sonido que trae la sega Mega Drive; Mega Drive dispone de los siguientes chips de sonido: Chip Yamaha YM2612 FM Chip. Texas Instruments PSG TI6489. Procesador Z80 para orquestar el sonido. Como podemos ver, hay 2 chips de sonido uno FM y otro para sonidos (8bit), estos dos chips son controlados por el controlador Z80 que es el encargado de funcionar. Note El procesador Z80 es el encargado de dar retrocompatibilidad con Master System por lo que en dicho modo no se tendr\u00e1 acceso al chip FM y solo estar\u00e1 disponible el PSG. El chip Yamaha YM2612, permite hasta 6 canales de audio en estereo teniendo una gran calidad de sonido; adem\u00e1s gracias al chip PSG se pueden combinar para poder ejecutar sonido y musica a la vez.","title":"Sonido en Mega Drive"},{"location":"devretro/sound-music/#formato-musica-xgmvgm","text":"A la hora de trabajar con la musica de Mega Drive /Genesis, vamos a ver un programa llamado VGM Music Maker; el cual nos permitir\u00e1 poder crear m\u00fasica para el chip Yamaha YM2612 y el PSG a la vez y poder crear nuestra musica a partir de instrumentos sintetizados. Una vez creada la m\u00fasica se debe exportar en formago XGM (extensi\u00f3n vgm). Adicionalmente, se pueden a\u00f1adir ficheros wav para los efectos de sonido.","title":"Formato M\u00fasica XGM(vgm)"},{"location":"devretro/sound-music/#anadir-sonido-a-nuestros-juegos","text":"Una vez ya hemos creado la musica y sonidos preparados, vamos a\u00f1adirlos a nuestro proyecto. En este caso, usaremos de forma analoga a como lo hicimos con los sprites y los fondos. Por lo que crearemos un fichero .res con la siguiente informaci\u00f3n: XGM sonic1 \"sonic1.vgm\" AUTO Donde: name: nombre del recurso. \"ruta\": ruta del fichero relativa a la carpeta res. AUTO: indica el TIMING; puede ser AUTO, PAL o NTSC. A la hora de a\u00f1adir ficheros de sonido, tendremos que utilizar la siguiente sintaxis. WAV name \"jump.wav\" PCM name: nombre del recurso. \"ruta\". Ruta del fichero relativa a la carpeta res. driver: indica el driver a utilizar (PCM, A2ADPCM, 4PCM, XGM). outrate: (solo si se usa el driver PCM). Una vez a\u00f1adidos los ficheros .res , compilaremos el proyecto y ya tendremos el fichero .h generado con todos los recursos. Tras haber a\u00f1adido los ficheros, vamos a ver las funciones que podemos utilizar para reproducir musica y sonido con SGDK. SND_startPlay_XGM(sonic_music); Esta funci\u00f3n reproduce la musica usando el fichero en formato XGM. En este caso, se reproducir\u00e1 por defecto en bucle. Note Es recomendable ejecutar esta funci\u00f3n deshabilitando las interrupciones; es decir, entre las funciones SYS_disableInts() y SYS_enableInts(); . SND_setPCM_XGM(SFX_JUMP, sonic_jump_sfx, sizeof(sonic_jump_sfx)) Esta funci\u00f3n inicializa el recurso de sonido, utilizando el driver correspondiente; en este caso el driver XGM. Estos son los par\u00e1metros de esta funci\u00f3n: ID: Identificador que le daremos al recurso (suele ser un n\u00famero). nombre_recurso: Nombre del recurso definido en el .res. tama\u00f1o: Tama\u00f1o del so0nido. SND_startPlayPCM_XGM(SFX_STOP, 1, SOUND_PCM_CH2); Esta funci\u00f3n reproduce el sonido inicializado con la anterior funci\u00f3n seleccionando el canal por que se reproducir\u00e1. Estos son los par\u00e1metros de la funci\u00f3n: ID: Identificador que se ha dado al inicializar el sonido. N_veces: N\u00ba de veces a reproducir. CANAL: Canal en el que reproducir este sonido. por ejemplo SOUND_PCM_CH2.","title":"A\u00f1adir sonido a nuestros juegos"},{"location":"devretro/sound-music/#ejemplo-con-musica","text":"Para terminar, vamos a finalizar el ejemplo que hemos realizado en este taller, a\u00f1adiendo m\u00fasica a nuestro juego; para ello, necesitaremos un fichero en formago vgm que puede descargar desde aqu\u00ed . Una vez se ha a\u00f1adido el fichero, pondremos el siguiente c\u00f3digo. /** Ejemplo5: Ejemplo de planos con Mega Drive **/ //Incluir libreria #include <genesis.h> // Incluir los recursos #include \"gfx.h\" #include \"sprt.h\" #include \"music.h\" //animaciones #define ANIM_RIGTH 1 #define ANIM_LEFT 3 #define ANIM_DOWN 2 #define ANIM_UP 0 #define ANIM_STAY 4 //Esta funcion nos ayudara a leer los controles void readcontrollers (); //Sprite Principal Sprite * mainsprt ; //Sprite Secundario Sprite * secondsprt ; u32 posx = 45 ; u32 posy = 155 ; //Funcion Principal int main () { //array donde se almacenara las paletas u16 palette [ 32 ]; //Para evitar problemas, se deshabilitan las interrupciones durante la carga SYS_disableInts (); // initializacion a 320 de ancho VDP_setScreenWidth320 (); // se establecen los colores de la paleta a negro VDP_setPaletteColors ( 0 , ( u16 * ) palette_black , 32 ); //Indice para pdoer saber la carga u16 ind = TILE_USERINDEX ; //dibuja un plano a partir de un recurso VDP_drawImageEx ( BG_B , & bga_image , TILE_ATTR_FULL ( PAL1 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bga_image . tileset -> numTile ; VDP_drawImageEx ( BG_A , & bgb_image , TILE_ATTR_FULL ( PAL0 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bgb_image . tileset -> numTile ; SND_startPlay_XGM ( theme ); //Se vuelven a activar las interrupciones SYS_enableInts (); //Inicializa motor de sprites con los par\u00e1metros por defecto SPR_init ( 0 , 0 , 0 ); mainsprt = SPR_addSprite ( & main_sprt , 15 , 125 , TILE_ATTR_FULL ( PAL2 , TRUE , FALSE , FALSE , ind )); secondsprt = SPR_addSprite ( & elli_sprt , 45 , 155 , TILE_ATTR ( PAL3 , TRUE , FALSE , FALSE )); // prepare palettes memcpy ( & palette [ 0 ], bgb_image . palette -> data , 16 * 2 ); memcpy ( & palette [ 16 ], bga_image . palette -> data , 16 * 2 ); VDP_setPalette ( PAL2 , main_sprt . palette -> data ); VDP_setPalette ( PAL3 , elli_sprt . palette -> data ); SPR_setAnim ( mainsprt , ANIM_STAY ); SPR_setAnim ( secondsprt , ANIM_STAY ); // fade in VDP_fadeIn ( 0 , ( 2 * 16 ) - 1 , palette , 20 , FALSE ); // bucle infinito while ( 1 ) { readcontrollers (); //actualiza el VDP SPR_update (); //Esperar refresco VDP_waitVSync (); } } void readcontrollers () { //Se lee el estado del joistick en el puerto 1 int value = JOY_readJoypad ( JOY_1 ); if ( value & BUTTON_RIGHT ){ SPR_setPosition ( secondsprt , posx ++ , posy ); SPR_setAnim ( secondsprt , ANIM_RIGTH ); } if ( value & BUTTON_LEFT ){ SPR_setPosition ( secondsprt , posx -- , posy ); SPR_setAnim ( secondsprt , ANIM_LEFT ); } if ( value & BUTTON_DOWN ) { SPR_setPosition ( secondsprt , posx , posy ++ ); SPR_setAnim ( secondsprt , ANIM_DOWN ); } if ( value & BUTTON_UP ) { SPR_setPosition ( secondsprt , posx , posy -- ); SPR_setAnim ( secondsprt , ANIM_UP ); } if ((( ! ( value & BUTTON_RIGHT )) && ( ! ( value & BUTTON_LEFT ))) && (( ! ( value & BUTTON_DOWN )) && ( ! ( value & BUTTON_UP )))) { SPR_setAnim ( secondsprt , ANIM_STAY ); } }","title":"Ejemplo con musica."},{"location":"devretro/sprites/","text":"Sprites \u00b6 Un Sprite, es un mapa de bits que va a ser representado en una pantalla de ordenador con un hardware especifico sin necesidad de calculos adicionales de CPU. Normalmente se asocia un sprite a un objeto a representar en un videojuego; como puede ser el jugador o cualquier enemigo. Normalmente un sprite se compone de una serie de imagenes que representan distintos frames a representar en la pantalla; cada frame se representar\u00e1 en un orden especifico para as\u00ed formar una animaci\u00f3n. Como se ve en la anterior imagen, este sprites se compone de una serie de imagenes que cada linea corresponde a una animaci\u00f3n; esto es importante cuando lleguemos a la parte de generar animaciones. Sin embargo, antes de continuar tenemos que tener en cuenta como funcionan los sprites dentro de la MegaDrive. Los sprites tienen su propio plano. La posicion de pantalla de los Sprites van en P\u00edxeles y no en Tiles. Podemos tener un total de 80 sprites por pantalla. Solo se pueden tener 20 sprites por linea horizontal. La manera de cargar un sprite es igual que los Planos (en pixels). Un sprites siempre debe ser divisible por 8 ya que de otra forma no se podr\u00eda cargar. El tama\u00f1o m\u00e1ximo de un sprites que SGDK permite manejar es de 16x16 tiles (128x128 p\u00edxeles). A\u00f1adir Sprites en SGDK \u00b6 Como hemos comentado, para cargar los sprites se hacen de igual forma que para los planos; sin embargo, tenemos que tener en cuenta una serie de cambios. Como por ejemplo como se a\u00f1ade el fichero de recuros (.res). Como con los planos, se debe crear un fichero para a\u00f1adir los recursos; por lo que se a\u00f1adira un fichero con extensi\u00f3n .res , con la siguiente informaci\u00f3n: SPRITE nombre_variable \"misprite.png\" tiles_ancho tiles_alto FAST veloc_ani Donde: SPRITE: indica el tipo de recurso nombre_variable: Nombre de la variable para referenciarlo en el c\u00f3digo. ruta del recurso: Ruta relativa donde se encuentra el recurso. tiles_ancho: N\u00famero de tiles de cada frame de ancho. tiles_alto: N\u00famero de tiles de cada frame de alto. compresi\u00f3n: Indica la compresi\u00f3n usada para a\u00f1adir el recurso. En este caso es FAST, pero puede ser NONE. veloc_ani: Velocidad de la animaci\u00f3n. Tiempo entre cada frame. collision (a partir de SGDK 1.41): Indica la caja de colision a utilizar (CIRCLE (circular), BOX (caja) o NONE (ninguna)). Una vez a\u00f1adido el fichero, compilaremos nuestro proyecto, y se generar\u00e1 un fichero .h en la carpeta res . Note Si queremos que se vuelvan a generar de nuevo los recursos, podemos hacerlo ejecutando el comando make y a\u00f1adiendo la opci\u00f3n clean . Con este fichero .h ya podemos a\u00f1adirlo a nuestro c\u00f3digo como hemos hecho para los planos: #include \"sprites.h\" Una vez hecho esto, tenemos en nuestro c\u00f3digo inicializar el motor de Sprites para poder utilizarlos. Para ello, usaremos la funci\u00f3n SPR_init . Ejemplo: SPR_init ( 0 , 0 , 0 ); //Normalmente se deja a 0 para que tome los valores por defecto. Una vez inicializado, a\u00f1adiremos el sprite (podemos a\u00f1adir a partir de una definici\u00f3n de Sprites, varios de ellos). Sprite * mainsprt = SPR_addSprite ( & main_sprt , 15 , 125 , TILE_ATTR_FULL ( PAL2 , TRUE , FALSE , FALSE , ind )); Por \u00faltimo es importante que se actualicen los sprites en cada frame por lo que necesitaremos la funci\u00f3n SPR_update() , sea llamada en cada frame. Ejemplo: while ( 1 ) { SPR_update (); VDP_waitVSync (); } Matem\u00e1ticas y F\u00edsica en SGDK \u00b6 Antes de continuar con las animaciones de los Sprites y como manejarlos en SGDK, vamos a ver un poco de como manejar las matem\u00e1ticas y f\u00edsica en MegaDrive; ya que el procesador Motorola 68000 no tiene soporte para coma flotante; esto quiere decir que no podemos usar decimales y todos los calculos son enteros. Es por ello, que necesitaremos una serie de tipo de datos para poder trabajar con decimales; por lo que SGDK nos define los siguientes datos: Tipo N\u00ba Bits (signo, entero, decimal) Rango fix16 16 (1, 9, 6) -512.00 a 511.00 fix32 32 (1,21,10) - 2097152.000 a 2097151.000 Seguidamente dejamos una serie de Funciones de utilidad para trabajar con este tipo de datos: Funciones Descripci\u00f3n Ejemplo FIX16(n\u00ba) Declara un nuevo Fix16 a partir de un n\u00famero FIX16(10.5); FIX32(n\u00ba) Declara un nuevo Fix32 a partir de un n\u00famero FIX32(3456.00); intToFix16(n\u00ba) Convierte un entero a fix16 intToFix16(value_s16); intToFix32(n\u00ba) Convierte un entero a fix32 intToFix32(value_s32); fix16ToInt(n\u00ba) Convierte un fix16 a entero (truncando) fix16ToInt(value_fix16); fix32ToInt(n\u00ba) Convierte un fix32 a entero(truncando) fix32Toint(value_fix32); fix16ToRoundedInt(n\u00ba) Convierte un fix16 a entero por redondeo fix16ToRoundedInt(value_fix16); fix32ToRoundedInt(n\u00ba) Convierte un fix32 a entero por redondeo fix32ToRoundedInt(value_fix32); fix16Add(a,b) Realiza la suma de dos fix16. fix16Add(a,b); fix32Add(a,b) Realiza la suma de dos fix32 fix32Add(a,b); fix16Sub(a,b) Realiza la resta de dos fix16 fix16Sub(a,b); fix32Sub(a,b) Realiza la resta de dos fix32 fix32Sub(a,b); fix16Mul(a,b) Realiza el producto de dos fix16 fix16Mul(a,b); fix32Mul(a,b) Realiza el producto de dos fix32 fix32Mul(a,b); fix16sqrt(a) Realiza la raiz cuardara de un fix16 fix16sqrt(value_fix16); fix32sqrt(a) Realiza la raiz cuadrada de un fix32 fixsqrt(value_fix32); sinFix16(v) Realiza el seno del angulo en radianes representado en el rango de 0 a 1024 sinFix16(FIX16(256.00)); cosFix32(v) Realiza el coseno del angulo en radianes representado en el rango de 0 a 1024 cosFix32(FIX32(512)); Animaciones en SGDK \u00b6 Tras conocer ya como trabajar con las matem\u00e1ticas y f\u00edsica con SGDK, vamos a pasar a hablar de las animaciones. Como hemos contando antes, un sprite se compone de una serie de frames que nos permitir\u00e1n hacer animaciones. Para realizar animaciones, necesitamos que cada una de ellas se encuentre en una linea (andar derecha, andar izquierda, atarcar,etc..), SGDK permite hasta 16 animaciones por sprite. Es importante conocer como esta compuesto nuestro sprite y saber de cuanto es cada frame (en tiles); esto lo hemos visto a la hora de a\u00f1adir sprites a nuestro proyecto. vamos a mostrar una imagen de prueba: Como vemos este sprite se compone de 4 filas de 3 frames cada una; si mostraramos la ejecuci\u00f3n de cada una se ver\u00eda la siguiente ejecuci\u00f3n: En cada momento podemos cambiar la animaci\u00f3n de nuestro sprite con la funci\u00f3n SPR_setAnim(sprite, n\u00ba animacion) ; esta funci\u00f3n debe ser llamada antes de actualizar el motor de sprites. Es importante saber, que cada fila representa una animaci\u00f3n y que empieza por 0. Note Siempre recomendamos usar constantes para definir nuestras animaciones. Plano de los Sprites \u00b6 Al igual que con los planos, los sprites tienen su propio plano en que se dibujaran; sin embargo, tambi\u00e9n disponen de prioridad y permite poder tener sensaci\u00f3n de profundidad. Podemos cambiar la prioridad del sprite con la funci\u00f3n SPR_setPriorityAttribut(sprite, TRUE| FALSE) ; la cual podemos definir si el sprite tiene prioridad o no. Ejemplo con Sprites \u00b6 Por \u00faltimo, vamos a hacer un peque\u00f1o ejemplo con Sprites donde mostraremos 2 sprites que dejamos las imagenes a continuaci\u00f3n: Enlace descarga imagenes Note La imagen del personaje con sombrero es de 16x16 pixeles cada frame mientras que el personaje con coletas es de 32x32 cada frame. Una vez descargas las imagenes y a\u00f1adidas al proyecto, crearemos el c\u00f3digo fuente: /** Ejemplo5: Ejemplo de planos con Mega Drive **/ //Incluir libreria #include <genesis.h> // Incluir los recursos #include \"gfx.h\" #include \"sprt.h\" //animaciones #define ANIM_RIGTH 1 #define ANIM_LEFT 3 #define ANIM_DOWN 2 #define ANIM_UP 0 #define ANIM_STAY 4 //Esta funcion nos ayudara a leer los controles void readcontrollers (); //Sprite Principal Sprite * mainsprt ; //Sprite Secundario Sprite * secondsprt ; u32 posx = 45 ; u32 posy = 155 ; //Funcion Principal int main () { //array donde se almacenara las paletas u16 palette [ 32 ]; //Para evitar problemas, se deshabilitan las interrupciones durante la carga SYS_disableInts (); // initializacion a 320 de ancho VDP_setScreenWidth320 (); // se establecen los colores de la paleta a negro VDP_setPaletteColors ( 0 , ( u16 * ) palette_black , 32 ); //Indice para pdoer saber la carga u16 ind = TILE_USERINDEX ; //dibuja un plano a partir de un recurso VDP_drawImageEx ( BG_B , & bga_image , TILE_ATTR_FULL ( PAL1 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bga_image . tileset -> numTile ; VDP_drawImageEx ( BG_A , & bgb_image , TILE_ATTR_FULL ( PAL0 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bgb_image . tileset -> numTile ; //Se vuelven a activar las interrupciones SYS_enableInts (); //Inicializa motor de sprites con los par\u00e1metros por defecto SPR_init ( 0 , 0 , 0 ); mainsprt = SPR_addSprite ( & main_sprt , 15 , 125 , TILE_ATTR_FULL ( PAL2 , TRUE , FALSE , FALSE , ind )); secondsprt = SPR_addSprite ( & elli_sprt , 45 , 155 , TILE_ATTR ( PAL3 , TRUE , FALSE , FALSE )); // prepare palettes memcpy ( & palette [ 0 ], bgb_image . palette -> data , 16 * 2 ); memcpy ( & palette [ 16 ], bga_image . palette -> data , 16 * 2 ); VDP_setPalette ( PAL2 , main_sprt . palette -> data ); VDP_setPalette ( PAL3 , elli_sprt . palette -> data ); SPR_setAnim ( mainsprt , ANIM_STAY ); SPR_setAnim ( secondsprt , ANIM_STAY ); // fade in VDP_fadeIn ( 0 , ( 2 * 16 ) - 1 , palette , 20 , FALSE ); // bucle infinito while ( 1 ) { readcontrollers (); //actualiza el VDP SPR_update (); //Esperar refresco VDP_waitVSync (); } } void readcontrollers () { //Se lee el estado del joistick en el puerto 1 int value = JOY_readJoypad ( JOY_1 ); if ( value & BUTTON_RIGHT ){ SPR_setPosition ( secondsprt , posx ++ , posy ); SPR_setAnim ( secondsprt , ANIM_RIGTH ); } if ( value & BUTTON_LEFT ){ SPR_setPosition ( secondsprt , posx -- , posy ); SPR_setAnim ( secondsprt , ANIM_LEFT ); } if ( value & BUTTON_DOWN ) { SPR_setPosition ( secondsprt , posx , posy ++ ); SPR_setAnim ( secondsprt , ANIM_DOWN ); } if ( value & BUTTON_UP ) { SPR_setPosition ( secondsprt , posx , posy -- ); SPR_setAnim ( secondsprt , ANIM_UP ); } if ((( ! ( value & BUTTON_RIGHT )) && ( ! ( value & BUTTON_LEFT ))) && (( ! ( value & BUTTON_DOWN )) && ( ! ( value & BUTTON_UP )))) { SPR_setAnim ( secondsprt , ANIM_STAY ); } } Note RECUERDA: Debes crear el fichero .res con la informaci\u00f3n tanto de los sprites, como de los fondos; fijate en el c\u00f3digo fuente para saber el nombre de los recursos. Si ejecutamos el juego en un emulador, se mostrara mas o menos asi: Ya tenemos nuestro juego casi finalizado; ya solo nos falta a\u00f1adir sonido y m\u00fasica.","title":"Sprites"},{"location":"devretro/sprites/#sprites","text":"Un Sprite, es un mapa de bits que va a ser representado en una pantalla de ordenador con un hardware especifico sin necesidad de calculos adicionales de CPU. Normalmente se asocia un sprite a un objeto a representar en un videojuego; como puede ser el jugador o cualquier enemigo. Normalmente un sprite se compone de una serie de imagenes que representan distintos frames a representar en la pantalla; cada frame se representar\u00e1 en un orden especifico para as\u00ed formar una animaci\u00f3n. Como se ve en la anterior imagen, este sprites se compone de una serie de imagenes que cada linea corresponde a una animaci\u00f3n; esto es importante cuando lleguemos a la parte de generar animaciones. Sin embargo, antes de continuar tenemos que tener en cuenta como funcionan los sprites dentro de la MegaDrive. Los sprites tienen su propio plano. La posicion de pantalla de los Sprites van en P\u00edxeles y no en Tiles. Podemos tener un total de 80 sprites por pantalla. Solo se pueden tener 20 sprites por linea horizontal. La manera de cargar un sprite es igual que los Planos (en pixels). Un sprites siempre debe ser divisible por 8 ya que de otra forma no se podr\u00eda cargar. El tama\u00f1o m\u00e1ximo de un sprites que SGDK permite manejar es de 16x16 tiles (128x128 p\u00edxeles).","title":"Sprites"},{"location":"devretro/sprites/#anadir-sprites-en-sgdk","text":"Como hemos comentado, para cargar los sprites se hacen de igual forma que para los planos; sin embargo, tenemos que tener en cuenta una serie de cambios. Como por ejemplo como se a\u00f1ade el fichero de recuros (.res). Como con los planos, se debe crear un fichero para a\u00f1adir los recursos; por lo que se a\u00f1adira un fichero con extensi\u00f3n .res , con la siguiente informaci\u00f3n: SPRITE nombre_variable \"misprite.png\" tiles_ancho tiles_alto FAST veloc_ani Donde: SPRITE: indica el tipo de recurso nombre_variable: Nombre de la variable para referenciarlo en el c\u00f3digo. ruta del recurso: Ruta relativa donde se encuentra el recurso. tiles_ancho: N\u00famero de tiles de cada frame de ancho. tiles_alto: N\u00famero de tiles de cada frame de alto. compresi\u00f3n: Indica la compresi\u00f3n usada para a\u00f1adir el recurso. En este caso es FAST, pero puede ser NONE. veloc_ani: Velocidad de la animaci\u00f3n. Tiempo entre cada frame. collision (a partir de SGDK 1.41): Indica la caja de colision a utilizar (CIRCLE (circular), BOX (caja) o NONE (ninguna)). Una vez a\u00f1adido el fichero, compilaremos nuestro proyecto, y se generar\u00e1 un fichero .h en la carpeta res . Note Si queremos que se vuelvan a generar de nuevo los recursos, podemos hacerlo ejecutando el comando make y a\u00f1adiendo la opci\u00f3n clean . Con este fichero .h ya podemos a\u00f1adirlo a nuestro c\u00f3digo como hemos hecho para los planos: #include \"sprites.h\" Una vez hecho esto, tenemos en nuestro c\u00f3digo inicializar el motor de Sprites para poder utilizarlos. Para ello, usaremos la funci\u00f3n SPR_init . Ejemplo: SPR_init ( 0 , 0 , 0 ); //Normalmente se deja a 0 para que tome los valores por defecto. Una vez inicializado, a\u00f1adiremos el sprite (podemos a\u00f1adir a partir de una definici\u00f3n de Sprites, varios de ellos). Sprite * mainsprt = SPR_addSprite ( & main_sprt , 15 , 125 , TILE_ATTR_FULL ( PAL2 , TRUE , FALSE , FALSE , ind )); Por \u00faltimo es importante que se actualicen los sprites en cada frame por lo que necesitaremos la funci\u00f3n SPR_update() , sea llamada en cada frame. Ejemplo: while ( 1 ) { SPR_update (); VDP_waitVSync (); }","title":"A\u00f1adir Sprites en SGDK"},{"location":"devretro/sprites/#matematicas-y-fisica-en-sgdk","text":"Antes de continuar con las animaciones de los Sprites y como manejarlos en SGDK, vamos a ver un poco de como manejar las matem\u00e1ticas y f\u00edsica en MegaDrive; ya que el procesador Motorola 68000 no tiene soporte para coma flotante; esto quiere decir que no podemos usar decimales y todos los calculos son enteros. Es por ello, que necesitaremos una serie de tipo de datos para poder trabajar con decimales; por lo que SGDK nos define los siguientes datos: Tipo N\u00ba Bits (signo, entero, decimal) Rango fix16 16 (1, 9, 6) -512.00 a 511.00 fix32 32 (1,21,10) - 2097152.000 a 2097151.000 Seguidamente dejamos una serie de Funciones de utilidad para trabajar con este tipo de datos: Funciones Descripci\u00f3n Ejemplo FIX16(n\u00ba) Declara un nuevo Fix16 a partir de un n\u00famero FIX16(10.5); FIX32(n\u00ba) Declara un nuevo Fix32 a partir de un n\u00famero FIX32(3456.00); intToFix16(n\u00ba) Convierte un entero a fix16 intToFix16(value_s16); intToFix32(n\u00ba) Convierte un entero a fix32 intToFix32(value_s32); fix16ToInt(n\u00ba) Convierte un fix16 a entero (truncando) fix16ToInt(value_fix16); fix32ToInt(n\u00ba) Convierte un fix32 a entero(truncando) fix32Toint(value_fix32); fix16ToRoundedInt(n\u00ba) Convierte un fix16 a entero por redondeo fix16ToRoundedInt(value_fix16); fix32ToRoundedInt(n\u00ba) Convierte un fix32 a entero por redondeo fix32ToRoundedInt(value_fix32); fix16Add(a,b) Realiza la suma de dos fix16. fix16Add(a,b); fix32Add(a,b) Realiza la suma de dos fix32 fix32Add(a,b); fix16Sub(a,b) Realiza la resta de dos fix16 fix16Sub(a,b); fix32Sub(a,b) Realiza la resta de dos fix32 fix32Sub(a,b); fix16Mul(a,b) Realiza el producto de dos fix16 fix16Mul(a,b); fix32Mul(a,b) Realiza el producto de dos fix32 fix32Mul(a,b); fix16sqrt(a) Realiza la raiz cuardara de un fix16 fix16sqrt(value_fix16); fix32sqrt(a) Realiza la raiz cuadrada de un fix32 fixsqrt(value_fix32); sinFix16(v) Realiza el seno del angulo en radianes representado en el rango de 0 a 1024 sinFix16(FIX16(256.00)); cosFix32(v) Realiza el coseno del angulo en radianes representado en el rango de 0 a 1024 cosFix32(FIX32(512));","title":"Matem\u00e1ticas y F\u00edsica en SGDK"},{"location":"devretro/sprites/#animaciones-en-sgdk","text":"Tras conocer ya como trabajar con las matem\u00e1ticas y f\u00edsica con SGDK, vamos a pasar a hablar de las animaciones. Como hemos contando antes, un sprite se compone de una serie de frames que nos permitir\u00e1n hacer animaciones. Para realizar animaciones, necesitamos que cada una de ellas se encuentre en una linea (andar derecha, andar izquierda, atarcar,etc..), SGDK permite hasta 16 animaciones por sprite. Es importante conocer como esta compuesto nuestro sprite y saber de cuanto es cada frame (en tiles); esto lo hemos visto a la hora de a\u00f1adir sprites a nuestro proyecto. vamos a mostrar una imagen de prueba: Como vemos este sprite se compone de 4 filas de 3 frames cada una; si mostraramos la ejecuci\u00f3n de cada una se ver\u00eda la siguiente ejecuci\u00f3n: En cada momento podemos cambiar la animaci\u00f3n de nuestro sprite con la funci\u00f3n SPR_setAnim(sprite, n\u00ba animacion) ; esta funci\u00f3n debe ser llamada antes de actualizar el motor de sprites. Es importante saber, que cada fila representa una animaci\u00f3n y que empieza por 0. Note Siempre recomendamos usar constantes para definir nuestras animaciones.","title":"Animaciones en SGDK"},{"location":"devretro/sprites/#plano-de-los-sprites","text":"Al igual que con los planos, los sprites tienen su propio plano en que se dibujaran; sin embargo, tambi\u00e9n disponen de prioridad y permite poder tener sensaci\u00f3n de profundidad. Podemos cambiar la prioridad del sprite con la funci\u00f3n SPR_setPriorityAttribut(sprite, TRUE| FALSE) ; la cual podemos definir si el sprite tiene prioridad o no.","title":"Plano de los Sprites"},{"location":"devretro/sprites/#ejemplo-con-sprites","text":"Por \u00faltimo, vamos a hacer un peque\u00f1o ejemplo con Sprites donde mostraremos 2 sprites que dejamos las imagenes a continuaci\u00f3n: Enlace descarga imagenes Note La imagen del personaje con sombrero es de 16x16 pixeles cada frame mientras que el personaje con coletas es de 32x32 cada frame. Una vez descargas las imagenes y a\u00f1adidas al proyecto, crearemos el c\u00f3digo fuente: /** Ejemplo5: Ejemplo de planos con Mega Drive **/ //Incluir libreria #include <genesis.h> // Incluir los recursos #include \"gfx.h\" #include \"sprt.h\" //animaciones #define ANIM_RIGTH 1 #define ANIM_LEFT 3 #define ANIM_DOWN 2 #define ANIM_UP 0 #define ANIM_STAY 4 //Esta funcion nos ayudara a leer los controles void readcontrollers (); //Sprite Principal Sprite * mainsprt ; //Sprite Secundario Sprite * secondsprt ; u32 posx = 45 ; u32 posy = 155 ; //Funcion Principal int main () { //array donde se almacenara las paletas u16 palette [ 32 ]; //Para evitar problemas, se deshabilitan las interrupciones durante la carga SYS_disableInts (); // initializacion a 320 de ancho VDP_setScreenWidth320 (); // se establecen los colores de la paleta a negro VDP_setPaletteColors ( 0 , ( u16 * ) palette_black , 32 ); //Indice para pdoer saber la carga u16 ind = TILE_USERINDEX ; //dibuja un plano a partir de un recurso VDP_drawImageEx ( BG_B , & bga_image , TILE_ATTR_FULL ( PAL1 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bga_image . tileset -> numTile ; VDP_drawImageEx ( BG_A , & bgb_image , TILE_ATTR_FULL ( PAL0 , FALSE , FALSE , FALSE , ind ), 0 , 0 , FALSE , TRUE ); ind += bgb_image . tileset -> numTile ; //Se vuelven a activar las interrupciones SYS_enableInts (); //Inicializa motor de sprites con los par\u00e1metros por defecto SPR_init ( 0 , 0 , 0 ); mainsprt = SPR_addSprite ( & main_sprt , 15 , 125 , TILE_ATTR_FULL ( PAL2 , TRUE , FALSE , FALSE , ind )); secondsprt = SPR_addSprite ( & elli_sprt , 45 , 155 , TILE_ATTR ( PAL3 , TRUE , FALSE , FALSE )); // prepare palettes memcpy ( & palette [ 0 ], bgb_image . palette -> data , 16 * 2 ); memcpy ( & palette [ 16 ], bga_image . palette -> data , 16 * 2 ); VDP_setPalette ( PAL2 , main_sprt . palette -> data ); VDP_setPalette ( PAL3 , elli_sprt . palette -> data ); SPR_setAnim ( mainsprt , ANIM_STAY ); SPR_setAnim ( secondsprt , ANIM_STAY ); // fade in VDP_fadeIn ( 0 , ( 2 * 16 ) - 1 , palette , 20 , FALSE ); // bucle infinito while ( 1 ) { readcontrollers (); //actualiza el VDP SPR_update (); //Esperar refresco VDP_waitVSync (); } } void readcontrollers () { //Se lee el estado del joistick en el puerto 1 int value = JOY_readJoypad ( JOY_1 ); if ( value & BUTTON_RIGHT ){ SPR_setPosition ( secondsprt , posx ++ , posy ); SPR_setAnim ( secondsprt , ANIM_RIGTH ); } if ( value & BUTTON_LEFT ){ SPR_setPosition ( secondsprt , posx -- , posy ); SPR_setAnim ( secondsprt , ANIM_LEFT ); } if ( value & BUTTON_DOWN ) { SPR_setPosition ( secondsprt , posx , posy ++ ); SPR_setAnim ( secondsprt , ANIM_DOWN ); } if ( value & BUTTON_UP ) { SPR_setPosition ( secondsprt , posx , posy -- ); SPR_setAnim ( secondsprt , ANIM_UP ); } if ((( ! ( value & BUTTON_RIGHT )) && ( ! ( value & BUTTON_LEFT ))) && (( ! ( value & BUTTON_DOWN )) && ( ! ( value & BUTTON_UP )))) { SPR_setAnim ( secondsprt , ANIM_STAY ); } } Note RECUERDA: Debes crear el fichero .res con la informaci\u00f3n tanto de los sprites, como de los fondos; fijate en el c\u00f3digo fuente para saber el nombre de los recursos. Si ejecutamos el juego en un emulador, se mostrara mas o menos asi: Ya tenemos nuestro juego casi finalizado; ya solo nos falta a\u00f1adir sonido y m\u00fasica.","title":"Ejemplo con Sprites"},{"location":"history/history/","text":"La Mega Drive es una videoconsola de sobremesa de 16 bits desarrollada por Sega Enterprises, Ltd. lanzada en Jap\u00f3n en 1988 y en Estados Unidos y Canad\u00e1 en 1989 con el nombre Genesis. Fue la tercera consola de Sega, sucesora de la Master System. En 1990 la Mega Drive fue distribuida en Europa, Australasia y Brasil, por Virgin Mastertronic, Ozisoft y Tec Toy respectivamente. Compiti\u00f3 comercialmente contra la SNES de Nintendo, como parte de las videoconsolas de cuarta generaci\u00f3n. Sega MegaDrive Modelo PAL Europeo Mega Drive fue una de las consolas m\u00e1s vendidas en la decada de los 90 pasando a venderse m\u00e1s de 30 millones de consolas. Adem\u00e1s de tener un gran catalogo de juegos, tambi\u00e9n disponia muchos perifericos como puede ser el Sega Activator . Sega Activator Seguidamente mostramos las caracter\u00edsticas de la Sega Mega Drive: Caracter\u00edstica Descripci\u00f3n CPU 1 Motorola 68000 de 16 bits a 7.61Mhz (PAL), 7.67Mhz (NTSC) CPU 2 Zilog Z80 de 8 bits a 3.55MHz (PAL), 3.58 Mhz (NTSC) Memoria RAM Principal: 64Kb; RAM Video: 64Kb; RAM Sonido: 8Kb V\u00eddeo Procesador VDP con resolucion de hasta 320x224 (320x240); capacidad de hasta 61 colores en pantalla (ampliable), 80 sprites maximo; 20 por pantalla Sonido Chip de sonido de 6 canales Yamaha YM2612; Chip adicional de sonido de 4 canales SN76489 y sonido 8 bits Entrada/Salida Slot de cartuchos por la parte superior; Slot de expansi\u00f3n para la Sega MegaCD ; 2 conectores para controladores; salida de auriculares estereo Sega Mega CD .","title":"Historia de la Mega Drive"},{"location":"history/m68k/","text":"Para poder desarrollar juegos antiguamente para la sega megaDrive se necesitaba conocer la arquitectura y el juego de instrucciones que manejaba el procesador Motorola 68000 que manejaba la Mega Drive. Por lo que era necesario conocer todo el hardware para poder desarrollar un juego y se utilizaba ensamblador en vez de lenguajes de m\u00e1s alto nivel como pueden ser C. Por si quiere profundizar m\u00e1s, dejamos un enlace a la Documentaci\u00f3n Oficial de Sega para desarrollar para Sega mega Drive . Desarrollo en Motorola 68000 para Sega Mega Drive Procesador Motorola68000 Seguidamente se muestra el hola mundo en ensamblador: #NO_APP .file \"main.c\" .section .rodata.str1.1 , \"aMS\" , @progbits , 1 .LC0: .string \"Hello Sega!!\" .section .text.startup , \"ax\" , @progbits .align 2 .globl main .type main , @function main: move.l %a2 ,-( %sp ) pea 13 .w pea 10 .w pea .LC0 jsr VDP_drawText lea ( 12 , %sp ), %sp lea VDP_waitVSync , %a2 .L2: jsr ( %a2 ) jsr ( %a2 ) jra .L2 .size main , .-main .ident \"GCC: (GNU) 6.3.0\"","title":"Desarrollo en Motorola 68000"},{"location":"sgdk/gens/","text":"Gens \u00b6 Para poder probar nuestros juegos y ver como funciona, vamos a instalar el emulador Gens ; el cual podremos instalar la versi\u00f3n modificada con KMod (Solo Windows). Seguidamente mostraremos como instalar este emulador en distintos sistemas Operativos: Windows \u00b6 Descargar el siguiente Zip y descomprimirlo en tu ordenador. KMod (Solo Windows) \u00b6 La versi\u00f3n de windows instalada tiene una versi\u00f3n modificada que nos permitir\u00e1 ver informaci\u00f3n de la Mega Drive; de forma que nos ayude a depurar nuestros juegos. Para ver este men\u00fa especial, podemos ir al men\u00fa CPU->debug->Genesis, para ver distintas opciones. Linux \u00b6 Descargar el fichero .deb (Para sistemas basados en Debian) o .rpm (Sistemas RH) del siguiente enlace ; e instalar en tu sistema usando el gestor de paquetes necesario. Note Esta version requiere que se tenga activado la gesti\u00f3n de depedencias con arquitectura i386 por lo que requerir\u00e1 ejecutar el siguiente comando dpkg --add-architecture i386 . Note Como alternativa a Gens, puede usarse el emulador Blastem ; el cual puede encontrarse en los repositorios Debian. MacOs (wine) \u00b6 Si ha instalado SGDK usando el m\u00e9todo con Wine, puede instalar GensK (versi\u00f3n con KMod) descargandolo desde la siguiente p\u00e1gina . Una vez descargado y descomprimido, realizaremos los siguientes pasos: mkdir $GENDEV /gens mv <carpetadondeseencuentregensk>/* $GENDEV /gens ln -sv $GENDEV /gens $GENDEV /wine/drive_C/gens","title":"Gens Emulador"},{"location":"sgdk/gens/#gens","text":"Para poder probar nuestros juegos y ver como funciona, vamos a instalar el emulador Gens ; el cual podremos instalar la versi\u00f3n modificada con KMod (Solo Windows). Seguidamente mostraremos como instalar este emulador en distintos sistemas Operativos:","title":"Gens"},{"location":"sgdk/gens/#windows","text":"Descargar el siguiente Zip y descomprimirlo en tu ordenador.","title":"Windows"},{"location":"sgdk/gens/#kmod-solo-windows","text":"La versi\u00f3n de windows instalada tiene una versi\u00f3n modificada que nos permitir\u00e1 ver informaci\u00f3n de la Mega Drive; de forma que nos ayude a depurar nuestros juegos. Para ver este men\u00fa especial, podemos ir al men\u00fa CPU->debug->Genesis, para ver distintas opciones.","title":"KMod (Solo Windows)"},{"location":"sgdk/gens/#linux","text":"Descargar el fichero .deb (Para sistemas basados en Debian) o .rpm (Sistemas RH) del siguiente enlace ; e instalar en tu sistema usando el gestor de paquetes necesario. Note Esta version requiere que se tenga activado la gesti\u00f3n de depedencias con arquitectura i386 por lo que requerir\u00e1 ejecutar el siguiente comando dpkg --add-architecture i386 . Note Como alternativa a Gens, puede usarse el emulador Blastem ; el cual puede encontrarse en los repositorios Debian.","title":"Linux"},{"location":"sgdk/gens/#macos-wine","text":"Si ha instalado SGDK usando el m\u00e9todo con Wine, puede instalar GensK (versi\u00f3n con KMod) descargandolo desde la siguiente p\u00e1gina . Una vez descargado y descomprimido, realizaremos los siguientes pasos: mkdir $GENDEV /gens mv <carpetadondeseencuentregensk>/* $GENDEV /gens ln -sv $GENDEV /gens $GENDEV /wine/drive_C/gens","title":"MacOs (wine)"},{"location":"sgdk/hola-mundo/","text":"Para poder trabajar con SGDK, necesitamos conocer la estructura de un proyecto para saber donde colocar los ficheros: carpeta src ; donde se incluiran los ficheros de c\u00f3digo (.c, .s ,etc...). carpeta inc ; donde se pondran los ficheros de cabeceras (.h, .m,etc...). carpeta res ; donde se incluiran los ficheros de recursos (imagenes, sonido, otros recursos). Para empezar, vamos a crear una carpeta (podemos usar Visual Studio Code ); donde se crear\u00e1 una carpeta llamada src ; dentro de esta carpeta crearemos el fichero hello.c ; con el siguiente contenido: /*Ejemplo 1: Hola Mundo.*/ //Incluir la libreria #include <genesis.h> //Funcion principal int main () { //Se muestra el texto Hello Sega en pantalla en la coordenada 10, 13 (esta en tiles no en pixels). VDP_drawText ( \"Hello Sega!\" , 10 , 13 ); while ( 1 ) //Bucle infinito para el juego { //Se espera el refresco de pantalla VDP_waitVSync (); } return ( 0 ); } Una vez escrito el codigo podemos usar Visual studio code para ejecutar el siguiente comando: Windows: %GDK_WIN% \\b in \\m ake -f %GDK_WIN% \\m akefile.gen Linux/Unix make -f $GENDEV /sgdk/mkfiles/makefile.gen clean all MacOs (Usando Wine) WINEPREFIX = $GENDEV /wine wine cmd %GDK_WIN% \\b in \\m ake -f %GDK_WIN \\m akefile.gen Note Quizas para linux o para Windows, puede ser necesario copiar el makefile que nos define en el kit de desarrollo. Una vez compilado, puede encontrarse en el directorio out un fichero llamado rom.bin ; el cual incluye la rom ya comp\u00eclada y lista para ser usada en un emulador (o hardware con un cartucho con tarjeta Flash). Note Todos los ejemplos, estaran disponibles en el repositorio de este mismo taller.","title":"Hola Mundo"},{"location":"sgdk/sgdk/","text":"SGDK (Sega Genesis Development Kit) es un kit de desarrollo para Sega MegaDrive. Este kit es gratuito y OpenSource; y fue desarrollado por Stephane Dallongeville . Este kit esta desarrollado en C y permite gracias a la librer\u00eda que trae generar ROMS que pueden ser utilizados tanto en un emulador, como en una Mega Drive real. El kit de Desarrollo SGDK incluye: Librer\u00eda de Desarrollo para Mega Drive. Conjunto de herramientas necesarias para manejar los recursos (Imagenes, Sprites, musica...). Un Compilador GCC; que permitir\u00e1 generar el binario compatible con el procesador Motorola 68000 (m68k-elf). Este kit de desarrollo tiene licencia MIT; excepto el compilador GCC que tiene licencia GNU (GPL3). Aqu\u00ed dejamos el enlace al repositorio de c\u00f3digo fuente: https://github.com/Stephane-D/SGDK Seguidamente veremos como se realizar\u00e1 la instalaci\u00f3n de este kit de desarrollo para los distintos Sistemas Operativos.","title":"SGDK"},{"location":"sgdk/vscode/","text":"Visual Studio Code \u00b6 Para poder realizar este taller; vamos a utilizar Visual Studio Code. Este editor nos permitir\u00e1 trabajar con los ejemplos que vamos a realizar. En primer lugar, vamos a instalar Visual Studio code; el cual pode\u00eds descargar desde el siguiente enlace . Para poder trabajar con SGDK y visual studio code, podemos usar 2 alternartivas. Plantilla de Tareas \u00b6 Una de las formas de poder trabajar con Visual Studio code y SGDK, es el usar una plantilla de tareas para Visual Studio Code. Para ello, vamos a utilizar el siguiente proyecto para poder utilizar SGDK tanto en Windows, como en Linux (usando Wine) o MAcOs( Tambi\u00e9n usando wine). Tambi\u00e9n permite utilizar el emulador Gens. Pod\u00e9is ver la plantilla desde el siguiente enlace Genesis Code \u00b6 Se ha creado una nueva extensi\u00f3n para Visual Studio Code, para poder integrar tanto la compilaci\u00f3n, como la creaci\u00f3n de proyectos para usar con SGDK o GENDEV. Pod\u00e9is descargar esta extensi\u00f3n desde el marketplace de Microsoft . Esta extensi\u00f3n permite realizar los siguientes comandos (que se pueden utilizar pulsando la combinaci\u00f3n CTRL + mayus + P ): Crear proyecto: Crea un proyecto nuevo generando un ejemplo completo de 'Hello World'. Compilar proyecto: LLama a SGDK para compilar y crear la rom. Limpiar proyecto: Llama a SGDK para limpiar el proyecto. Ejecutar Proyecto: Ejecuta el emulador gens con la rom del proyecto actual (dentro de la carpeta out). Compilar y ejecutar proyecto: Compila y despu\u00e9s ejecuta el emulador gens de la rom generada. Establecer el comando para ejecutar gens: Actualiza la configuraci\u00f3n para establecer como se llamar\u00e1 al emulador gens. Te permite autocompletado para los ficheros de recursos de SGDK. Note Tambi\u00e9n se puede establecer el comando desde la configuraci\u00f3n de VSCode ( CTRL + , ). Note Este comando es compatible con cualquier emulador que pueda usarse como Blastem. Para m\u00e1s informaci\u00f3n acerca de Genesis code, puedes consultar el proyecto en Github .","title":"VS Code"},{"location":"sgdk/vscode/#visual-studio-code","text":"Para poder realizar este taller; vamos a utilizar Visual Studio Code. Este editor nos permitir\u00e1 trabajar con los ejemplos que vamos a realizar. En primer lugar, vamos a instalar Visual Studio code; el cual pode\u00eds descargar desde el siguiente enlace . Para poder trabajar con SGDK y visual studio code, podemos usar 2 alternartivas.","title":"Visual Studio Code"},{"location":"sgdk/vscode/#plantilla-de-tareas","text":"Una de las formas de poder trabajar con Visual Studio code y SGDK, es el usar una plantilla de tareas para Visual Studio Code. Para ello, vamos a utilizar el siguiente proyecto para poder utilizar SGDK tanto en Windows, como en Linux (usando Wine) o MAcOs( Tambi\u00e9n usando wine). Tambi\u00e9n permite utilizar el emulador Gens. Pod\u00e9is ver la plantilla desde el siguiente enlace","title":"Plantilla de Tareas"},{"location":"sgdk/vscode/#genesis-code","text":"Se ha creado una nueva extensi\u00f3n para Visual Studio Code, para poder integrar tanto la compilaci\u00f3n, como la creaci\u00f3n de proyectos para usar con SGDK o GENDEV. Pod\u00e9is descargar esta extensi\u00f3n desde el marketplace de Microsoft . Esta extensi\u00f3n permite realizar los siguientes comandos (que se pueden utilizar pulsando la combinaci\u00f3n CTRL + mayus + P ): Crear proyecto: Crea un proyecto nuevo generando un ejemplo completo de 'Hello World'. Compilar proyecto: LLama a SGDK para compilar y crear la rom. Limpiar proyecto: Llama a SGDK para limpiar el proyecto. Ejecutar Proyecto: Ejecuta el emulador gens con la rom del proyecto actual (dentro de la carpeta out). Compilar y ejecutar proyecto: Compila y despu\u00e9s ejecuta el emulador gens de la rom generada. Establecer el comando para ejecutar gens: Actualiza la configuraci\u00f3n para establecer como se llamar\u00e1 al emulador gens. Te permite autocompletado para los ficheros de recursos de SGDK. Note Tambi\u00e9n se puede establecer el comando desde la configuraci\u00f3n de VSCode ( CTRL + , ). Note Este comando es compatible con cualquier emulador que pueda usarse como Blastem. Para m\u00e1s informaci\u00f3n acerca de Genesis code, puedes consultar el proyecto en Github .","title":"Genesis Code"},{"location":"sgdk/instalacion/linux/","text":"Instalaci\u00f3n en Linux \u00b6 Aunque no existe una versi\u00f3n oficial para Linux, si que existen proyectos como gendev que nos ayudan a poder tener todas las herramientas preparadas para este sistema Operativo, como gendev . Note Estas instrucciones solo ser\u00e1n v\u00e1lidas para Linux 64 bits; por lo que en otras arquitecturas tendr\u00e1n que compilarse a mano todas las dependencias. Antes de comenzar a utilizar gendev, se deben de instalar los siguientes prerequisitos: texinfo. java (ya sea openjdk o la versi\u00f3n de Oracle). Una vez instalados los anteriores paquetes (usando cualquier gestor de paquetes de su distribuci\u00f3n), podemos pasar a descargar e instalar gendev. Para descargar gendev, podemos ir a la p\u00e1gina de Relases del repositorio del proyecto. Note Como puede verse, se puede descargar en formato .deb o como tar.gz ; recomendamos utilizar el formato .deb en el caso de usar este formato (Debian); si su distribuci\u00f3n no lo soporta, usar la otra alternativa. Recordad que para instalar un paquete .deb se debe usar el siguiente comando: dpkg -i <fichero.deb> Una vez descargado e instalado (o descomprimido), vamos a pasar a configurar el entorno; para ello definimos la variable de entorno GENDEV que apunte a la ruta donde se encuentre instalado el gendev. export GENDEV = /opt/gendev Note Si se instala usando el paquete deb, la ruta por defecto es /opt/gendev . Note Puede a\u00f1adirse al perfil bash del usuario para que siempre este a\u00f1adido. Una vez hecho esto, ya podremos utilizar gendev o sgdk sin ning\u00fan problema. Compilar la librer\u00eda \u00b6 Aunque ya viene con una versi\u00f3n compilada del Kit de desarrollo y todas las herramientas necesarias, quizas sea necesario compilar la librer\u00eda y todo el kit a partir del c\u00f3digo fuente. Por lo que para poder compilar todas las herramientas, necesitaremos las siguientes dependencias: git build-essential texinfo curl wget unzip Tras esto se clona el repositorio del proyecto de gendev y se realizan los siguientes comandos: cd gendev make Note La compilaci\u00f3n tardar\u00e1 sobre unos 45 minutos.","title":"Linux"},{"location":"sgdk/instalacion/linux/#instalacion-en-linux","text":"Aunque no existe una versi\u00f3n oficial para Linux, si que existen proyectos como gendev que nos ayudan a poder tener todas las herramientas preparadas para este sistema Operativo, como gendev . Note Estas instrucciones solo ser\u00e1n v\u00e1lidas para Linux 64 bits; por lo que en otras arquitecturas tendr\u00e1n que compilarse a mano todas las dependencias. Antes de comenzar a utilizar gendev, se deben de instalar los siguientes prerequisitos: texinfo. java (ya sea openjdk o la versi\u00f3n de Oracle). Una vez instalados los anteriores paquetes (usando cualquier gestor de paquetes de su distribuci\u00f3n), podemos pasar a descargar e instalar gendev. Para descargar gendev, podemos ir a la p\u00e1gina de Relases del repositorio del proyecto. Note Como puede verse, se puede descargar en formato .deb o como tar.gz ; recomendamos utilizar el formato .deb en el caso de usar este formato (Debian); si su distribuci\u00f3n no lo soporta, usar la otra alternativa. Recordad que para instalar un paquete .deb se debe usar el siguiente comando: dpkg -i <fichero.deb> Una vez descargado e instalado (o descomprimido), vamos a pasar a configurar el entorno; para ello definimos la variable de entorno GENDEV que apunte a la ruta donde se encuentre instalado el gendev. export GENDEV = /opt/gendev Note Si se instala usando el paquete deb, la ruta por defecto es /opt/gendev . Note Puede a\u00f1adirse al perfil bash del usuario para que siempre este a\u00f1adido. Una vez hecho esto, ya podremos utilizar gendev o sgdk sin ning\u00fan problema.","title":"Instalaci\u00f3n en Linux"},{"location":"sgdk/instalacion/linux/#compilar-la-libreria","text":"Aunque ya viene con una versi\u00f3n compilada del Kit de desarrollo y todas las herramientas necesarias, quizas sea necesario compilar la librer\u00eda y todo el kit a partir del c\u00f3digo fuente. Por lo que para poder compilar todas las herramientas, necesitaremos las siguientes dependencias: git build-essential texinfo curl wget unzip Tras esto se clona el repositorio del proyecto de gendev y se realizan los siguientes comandos: cd gendev make Note La compilaci\u00f3n tardar\u00e1 sobre unos 45 minutos.","title":"Compilar la librer\u00eda"},{"location":"sgdk/instalacion/macos/","text":"Instalaci\u00f3n en Mac OS \u00b6 Para poder utilizar en MacOs gendev, existe un proyecto que pod\u00e9is ver en el siguiente enlace ; sin embargo es un proyecto discontinuado. Sin embargo, pueden usarse las instrucciones para Linux ; para poder tratar de compilarlo. Metodo Alternativo para MACOs (Wine) \u00b6 Se puede utilizar Wine para poder desde MacOs utilizar SGDK. Para ello se puede utilizar una plantilla con las tareas necesarias para compilar y ejecutar nuestros proyectos. Seguidamente se muestran los pasos necesarios para poder utilizar SGDK con Wine. Note Estos pasos tambien son compatibles con Unix/Linux. En primer lugar, crearemos la carpeta y variables de entorno necesarias para el funcionamiento de SGDK y Gens. sudo mkdir /opt/gendev sudo chown $USER : /opt/gendev Las variables de entorno: export GENDEV = /opt/gendev export GDK = 'c:/sgdk' export GDK_WIN = 'c:\\sgdk' export GENS = $GENDEV /gens/genes.exe Note Puedes hacer que estas variables sean permanentes guardandolas en el fichero .bash_profile o .zshrc Tras tener las variables y carpetas creadas vamos a utilizar el gestor de paquetes brew para instalar los siguientes paquetes. brew cask install xquartz brew install wine Note Para instalar brew seguir las siguientes instrucciones . Tras tener los dos paquetes instalados vamos a pasar a configurar wine mkdir $GENDEV /wine WINEDEBUG = -all WINEARCH = win32 WINEPREFIX = $GENDEV /wine wineboot Una vez ya tenemos wine instalado y configurado, vamos a pasar a instalar y compilar las librerias de SGDK. cd $GENDEV git clone https://github.com/Stephane-D/SGDK.git ln -sv $GENDEV /SGDK $GENDEV /wine/drive_c sgdk Como hemos comentado en el apartado de Windows y Linux, es requerido tener instalado el entorno Java. Por lo que se deber\u00e1 instalar la version del JRE (o JDK) de Java para Windows X86 (Es importante que sea la versi\u00f3n de windows). Una vez descargado pasaremos a realizar los siguientes comandos. cd <ruta donde se encuentre el exe de java> WINEPREFIX = $GENDEV /wine wine cmd Esto abrira un cmd usando Wine. El cual nos motrar\u00e1 la ruta donde nos encontremos. En este terminal escribiremos lo siguiente: z:\\> jdk-8u221-windows-i586.exe /s Una vez instalado, tenemos que actualizar el PATH del sistema Wine para que reconozca el comando java. Por lo que ejecutaremos la utilidad de regedit . WINEPREFIX = $GENDEV /wine wine regedit Una vez abierta la utilidad, iremos a la siguiente ruta en el registro: HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Environment y modificaremos la variable PATH para a\u00f1adir la ruta donde se encuentre instalado el JRE (o JDK). Note Es importante que se a\u00f1ada al path y no se borre el contenido de esta. Simplemente hay que a\u00f1adir la ruta al final separando de la anterior por un ;. Note La ruta que hay que poner es C:\\Program Files\\Java\\jdk1.8.0_xxx\\bin los 3 numeros corresponden a la actualizacion descargada. Una vez tenemos instalado java y todas las herramientas, vamos a compilar la libreria que nos provee SGDK. WINEPREFIX = $GENDEV /wine wine cmd %GDK_WIN% \\b in \\m ake -f %GDK_WIN \\m akelib.gen Por \u00faltimo, descargaremos el template y podremos usarlo desde vscode. mkdir workdir cd workdir git clone https://github.com/v4ld3r5/sgdk_vscode_template.git Note Para poder ver las plantillas puede pulsar la combinacion CTRL + mayus + B","title":"Mac OS"},{"location":"sgdk/instalacion/macos/#instalacion-en-mac-os","text":"Para poder utilizar en MacOs gendev, existe un proyecto que pod\u00e9is ver en el siguiente enlace ; sin embargo es un proyecto discontinuado. Sin embargo, pueden usarse las instrucciones para Linux ; para poder tratar de compilarlo.","title":"Instalaci\u00f3n en Mac OS"},{"location":"sgdk/instalacion/macos/#metodo-alternativo-para-macos-wine","text":"Se puede utilizar Wine para poder desde MacOs utilizar SGDK. Para ello se puede utilizar una plantilla con las tareas necesarias para compilar y ejecutar nuestros proyectos. Seguidamente se muestran los pasos necesarios para poder utilizar SGDK con Wine. Note Estos pasos tambien son compatibles con Unix/Linux. En primer lugar, crearemos la carpeta y variables de entorno necesarias para el funcionamiento de SGDK y Gens. sudo mkdir /opt/gendev sudo chown $USER : /opt/gendev Las variables de entorno: export GENDEV = /opt/gendev export GDK = 'c:/sgdk' export GDK_WIN = 'c:\\sgdk' export GENS = $GENDEV /gens/genes.exe Note Puedes hacer que estas variables sean permanentes guardandolas en el fichero .bash_profile o .zshrc Tras tener las variables y carpetas creadas vamos a utilizar el gestor de paquetes brew para instalar los siguientes paquetes. brew cask install xquartz brew install wine Note Para instalar brew seguir las siguientes instrucciones . Tras tener los dos paquetes instalados vamos a pasar a configurar wine mkdir $GENDEV /wine WINEDEBUG = -all WINEARCH = win32 WINEPREFIX = $GENDEV /wine wineboot Una vez ya tenemos wine instalado y configurado, vamos a pasar a instalar y compilar las librerias de SGDK. cd $GENDEV git clone https://github.com/Stephane-D/SGDK.git ln -sv $GENDEV /SGDK $GENDEV /wine/drive_c sgdk Como hemos comentado en el apartado de Windows y Linux, es requerido tener instalado el entorno Java. Por lo que se deber\u00e1 instalar la version del JRE (o JDK) de Java para Windows X86 (Es importante que sea la versi\u00f3n de windows). Una vez descargado pasaremos a realizar los siguientes comandos. cd <ruta donde se encuentre el exe de java> WINEPREFIX = $GENDEV /wine wine cmd Esto abrira un cmd usando Wine. El cual nos motrar\u00e1 la ruta donde nos encontremos. En este terminal escribiremos lo siguiente: z:\\> jdk-8u221-windows-i586.exe /s Una vez instalado, tenemos que actualizar el PATH del sistema Wine para que reconozca el comando java. Por lo que ejecutaremos la utilidad de regedit . WINEPREFIX = $GENDEV /wine wine regedit Una vez abierta la utilidad, iremos a la siguiente ruta en el registro: HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Environment y modificaremos la variable PATH para a\u00f1adir la ruta donde se encuentre instalado el JRE (o JDK). Note Es importante que se a\u00f1ada al path y no se borre el contenido de esta. Simplemente hay que a\u00f1adir la ruta al final separando de la anterior por un ;. Note La ruta que hay que poner es C:\\Program Files\\Java\\jdk1.8.0_xxx\\bin los 3 numeros corresponden a la actualizacion descargada. Una vez tenemos instalado java y todas las herramientas, vamos a compilar la libreria que nos provee SGDK. WINEPREFIX = $GENDEV /wine wine cmd %GDK_WIN% \\b in \\m ake -f %GDK_WIN \\m akelib.gen Por \u00faltimo, descargaremos el template y podremos usarlo desde vscode. mkdir workdir cd workdir git clone https://github.com/v4ld3r5/sgdk_vscode_template.git Note Para poder ver las plantillas puede pulsar la combinacion CTRL + mayus + B","title":"Metodo Alternativo para MACOs (Wine)"},{"location":"sgdk/instalacion/windows/","text":"Instalacion en Windows \u00b6 Para instalar en Windows el kit de desarrollo se requiere tener instalado el entorno de Ejecuci\u00f3n java (JRE); el cual puede descargarse desde la p\u00e1gina oficial de Oracle ; o usarse la alternativa de openjdk . Note Requiere Java 1.8 o superior. Tras tener java instalado, procederemos a realizar las siguientes instrucciones: 1.- Descargar SGDK de la parte de releases ; tras descargarlo, descomprimir donde queramos. 2.- Definir la variable de entorno GDK que apunte a la ruta donde nos descargamos el kit de desarrollo. Note La ruta debe establecerse en formato UNIX. 3.- Definir la variable de entorno GDK_WIN que debe apuntar a la ruta donde nos descargamos el kit de desarrollo. Note La ruta debe establecerse en formato WINDOWS. 4.- Definir en el PATH de windows la ruta del directorio bin donde se encuentre el SGDK descomprimido; es decir, el valor %GDK_WIN%\\bin . Note Hay que tener cuidado si ya se tenia instalado en el path un comando como gcc ya que puede dar conflicto. Compilar la libreria \u00b6 Normalmente, ya viene una versi\u00f3n compilada de la libreria para desarrollo para Mega Drive; sin embargo, si se requiere compilar de nuevo, esto puede hacerse ejecutando el siguiente comando en la carpeta principal del proyecto. %GDK_WIN% \\b in \\m ake -f makelib.gen","title":"Windows"},{"location":"sgdk/instalacion/windows/#instalacion-en-windows","text":"Para instalar en Windows el kit de desarrollo se requiere tener instalado el entorno de Ejecuci\u00f3n java (JRE); el cual puede descargarse desde la p\u00e1gina oficial de Oracle ; o usarse la alternativa de openjdk . Note Requiere Java 1.8 o superior. Tras tener java instalado, procederemos a realizar las siguientes instrucciones: 1.- Descargar SGDK de la parte de releases ; tras descargarlo, descomprimir donde queramos. 2.- Definir la variable de entorno GDK que apunte a la ruta donde nos descargamos el kit de desarrollo. Note La ruta debe establecerse en formato UNIX. 3.- Definir la variable de entorno GDK_WIN que debe apuntar a la ruta donde nos descargamos el kit de desarrollo. Note La ruta debe establecerse en formato WINDOWS. 4.- Definir en el PATH de windows la ruta del directorio bin donde se encuentre el SGDK descomprimido; es decir, el valor %GDK_WIN%\\bin . Note Hay que tener cuidado si ya se tenia instalado en el path un comando como gcc ya que puede dar conflicto.","title":"Instalacion en Windows"},{"location":"sgdk/instalacion/windows/#compilar-la-libreria","text":"Normalmente, ya viene una versi\u00f3n compilada de la libreria para desarrollo para Mega Drive; sin embargo, si se requiere compilar de nuevo, esto puede hacerse ejecutando el siguiente comando en la carpeta principal del proyecto. %GDK_WIN% \\b in \\m ake -f makelib.gen","title":"Compilar la libreria"}]}